<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>FreeRTOS相关知识点</title>
    <url>/2023/08/29/FreeRTOS%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="FreeRTOS相关知识点"><a href="#FreeRTOS相关知识点" class="headerlink" title="FreeRTOS相关知识点"></a>FreeRTOS相关知识点</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><pre><code>  - [挂起：挂起的任务类似暂停，可恢复（解挂）；删除任务，无法恢复。被挂起的任务绝不会得到CPU的使用权，不管该任务具有什么优先级。vTaskSuspend() 函数调用时需要将宏INCLUDE_vTaskSuspend() 配置成1。](#section.1)&lt;a name=&quot;context.1&quot;&gt; &lt;/a&gt;
  - [恢复：恢复被挂起的任务。==任务恢复就是让挂起的任务重新进入就绪状态，恢复的任务会保留挂起前的状态信息，在恢复时根据挂起时的状态继续运行。vTaskResume() 函数调用时需要将宏INCLUDE_vTaskResume() 配置成1==](#section.2)&lt;a name=&quot;context.2&quot;&gt; &lt;/a&gt;
    - [FromISR：==带FromISR后缀是在中断函数中专用的API==。无论调用过多少次的任务挂起vTaskSuspend() ，只需要调用一次vTaskResumeFromISR()  即可解挂。==使用该函数时，需要在FreeRTOSconfig.h中把INCLUDE_vTaskSuspend()和INCLUDE_vTaskResumeFromISR()  都定义为1。==vTaskResumeFromISR()函数不能用于任务和中断的同步（因为中断随时可能出现）。](#section.3)&lt;a name=&quot;context.3&quot;&gt; &lt;/a&gt;
</code></pre>
<hr>
<p>​    FreeRTOS支持的三种调度方式：<br>  （1）抢占式调度：主要是针对优先级不同的任务，每一个任务都有一个优先级，优先级高的任务可以抢占优先级低的任务。<br>  （2）时间片调度：主要是针对优先级相同的任务，当多个任务的优先级相同时，任务调度器会在每一个时钟节拍到的时候切换任务。         （时间片1ms）在FreeRTOS中，一个时间片就是SysTick中断周期。更改时间片的大小，可由更改滴答定时器中断周期去实现。<br>​     补充：时间片：同等优先级的任务轮流的享有相同的CPU时间。在FreeRTOS中，一个时间片就等于一个SysTick中断周期<br>  （3）协程式调度：当前执行的任务会一直执行，同时高优先级的任务不会抢占低优先级的任务。</p>
<ol>
<li><h2 id="FreeRTOS中任务共存在四种状态："><a href="#FreeRTOS中任务共存在四种状态：" class="headerlink" title="FreeRTOS中任务共存在四种状态："></a>FreeRTOS中任务共存在四种状态：</h2></li>
</ol>
<p>  （1）运行态：正在执行的任务，该任务就处于运行态，注意在STM32中，同一时间仅有一个任务处于运行态。<br>  （2）就绪态：如果该任务已经能够被执行，但当前还未被执行，那么该任务处于就绪态。<br>  （3）阻塞态：如果一个任务因为延时或等待外部事件发生，那么这个任务就处于阻塞态。<br>  （4）挂起态：类似暂停，需要调用函数vTaskSuspend()进入挂起态，调用解挂vTaskResume()才可以进入到就绪态。&#x3D;&#x3D;注意：任务处于挂起态的时候经过解挂不会直接进入到运行态，只会进入到就绪态。同样阻塞态也不会直接进行到运行态，会进入到就绪态。仅就绪态可转变为运行态，其他状态的任务想运行，必须先转为就绪态。&#x3D;&#x3D;</p>
<ol start="2">
<li><h2 id="系统配置文件："><a href="#系统配置文件：" class="headerlink" title="系统配置文件："></a>系统配置文件：</h2></li>
</ol>
<p>  FreeRTOSConfig.h 配置文件作用：对FreeRTOS进行功能配置和裁剪，以及API函数的使能。<br>  （1）“INCLUDE”： 配置FreeRTOS中可选的API<br>  （2）“config” ：完成FreeRTOS的功能配置和裁剪<br>  （3）其他的配置项：完成PendSV（中断）宏定义、SVC宏定义</p>
<ol start="3">
<li><h2 id="任务的创建和删除的API函数"><a href="#任务的创建和删除的API函数" class="headerlink" title="任务的创建和删除的API函数"></a>任务的创建和删除的API函数</h2><p>   ​    &#x3D;&#x3D;任务的创建和删除的本质就是调用FreeRTOS的API函数&#x3D;&#x3D;<br>   ​       两种创建方式：（1）&#x3D;&#x3D;动态方式创建&#x3D;&#x3D;（xTaskCreate）———任务的任务控制块以及任务的栈空间所需的内存，&#x3D;&#x3D;均由FreeRTOS从FreeRTOS管理的堆中分配&#x3D;&#x3D;。（2）&#x3D;&#x3D;静态方式创建&#x3D;&#x3D;（xTaskCreateStatic）———任务的任务控制块以及任务的栈空间所需的内存，&#x3D;&#x3D;需要用户分配提供。&#x3D;&#x3D;任务删除函数（xTaskToDelete）待删除任务的任务句柄，用于删除已被创键的任务，被删除的任务将从就绪态任务列表、阻塞态任务列表、挂起态任务列表和事件列表中移除。</p>
<p>   静态创建任务流程：（1）使用静态创建任务，需要将宏configSUPPORT_STATIC_ALLOCATION配置成1<br>                                 （2）定义空闲任务和定时器任务的任务堆栈及TCB<br>                                 （3）实现两个接口函数vApplicationGetldleTaskMemory()、vApplicationGetTimerTaskMemory()<br>                                 （4） 编写任务函数<br>   删除任务流程：        （1）使用删除任务函数，需要将宏INCLUDE_vTask Delete配置为1 </p>
<p>   ​                                   （2）入口参数输入需要删除的任务句柄（NULL代表删除本身）。删除任务自身，需要先添加等待删除列表，内     存释放将放在空闲任务执行 ，空闲任务会负责释放被删除任务中由系统分配的内存，但是由用户在任务删除前申请的内存，则需要由用户在任务被删除前提前释放，否则会导致内存泄漏。</p>
</li>
<li><h2 id="任务的挂起与恢复的API函数"><a href="#任务的挂起与恢复的API函数" class="headerlink" title="任务的挂起与恢复的API函数"></a>任务的挂起与恢复的API函数</h2></li>
</ol>
<p>  ​      三个API函数：（1）vTaskSuspend()                     ———挂起任务<br>  ​                               （2）vTaskResume()                      ———恢复被挂起的任务<br>  ​                               （3）vTaskResumeFromISR()       ———在中断中恢复被挂起的任务</p>
<h5 id="挂起：挂起的任务类似暂停，可恢复（解挂）；删除任务，无法恢复。被挂起的任务绝不会得到CPU的使用权，不管该任务具有什么优先级。vTaskSuspend-函数调用时需要将宏INCLUDE-vTaskSuspend-配置成1。"><a href="#挂起：挂起的任务类似暂停，可恢复（解挂）；删除任务，无法恢复。被挂起的任务绝不会得到CPU的使用权，不管该任务具有什么优先级。vTaskSuspend-函数调用时需要将宏INCLUDE-vTaskSuspend-配置成1。" class="headerlink" title="挂起：挂起的任务类似暂停，可恢复（解挂）；删除任务，无法恢复。被挂起的任务绝不会得到CPU的使用权，不管该任务具有什么优先级。vTaskSuspend() 函数调用时需要将宏INCLUDE_vTaskSuspend() 配置成1。 "></a><a href="#context.1">挂起：挂起的任务类似暂停，可恢复（解挂）；删除任务，无法恢复。被挂起的任务绝不会得到CPU的使用权，不管该任务具有什么优先级。vTaskSuspend() 函数调用时需要将宏INCLUDE_vTaskSuspend() 配置成1。</a><a name="section.1"> </a></h5><h5 id="恢复：恢复被挂起的任务。-任务恢复就是让挂起的任务重新进入就绪状态，恢复的任务会保留挂起前的状态信息，在恢复时根据挂起时的状态继续运行。vTaskResume-函数调用时需要将宏INCLUDE-vTaskResume-配置成1"><a href="#恢复：恢复被挂起的任务。-任务恢复就是让挂起的任务重新进入就绪状态，恢复的任务会保留挂起前的状态信息，在恢复时根据挂起时的状态继续运行。vTaskResume-函数调用时需要将宏INCLUDE-vTaskResume-配置成1" class="headerlink" title="恢复：恢复被挂起的任务。&#x3D;&#x3D;任务恢复就是让挂起的任务重新进入就绪状态，恢复的任务会保留挂起前的状态信息，在恢复时根据挂起时的状态继续运行。vTaskResume() 函数调用时需要将宏INCLUDE_vTaskResume() 配置成1&#x3D;&#x3D; "></a><a href="#context.2">恢复：恢复被挂起的任务。&#x3D;&#x3D;任务恢复就是让挂起的任务重新进入就绪状态，恢复的任务会保留挂起前的状态信息，在恢复时根据挂起时的状态继续运行。vTaskResume() 函数调用时需要将宏INCLUDE_vTaskResume() 配置成1&#x3D;&#x3D;</a><a name="section.2"> </a></h5><h6 id="FromISR：-带FromISR后缀是在中断函数中专用的API-。无论调用过多少次的任务挂起vTaskSuspend-，只需要调用一次vTaskResumeFromISR-即可解挂。-使用该函数时，需要在FreeRTOSconfig-h中把INCLUDE-vTaskSuspend-和INCLUDE-vTaskResumeFromISR-都定义为1。-vTaskResumeFromISR-函数不能用于任务和中断的同步（因为中断随时可能出现）。"><a href="#FromISR：-带FromISR后缀是在中断函数中专用的API-。无论调用过多少次的任务挂起vTaskSuspend-，只需要调用一次vTaskResumeFromISR-即可解挂。-使用该函数时，需要在FreeRTOSconfig-h中把INCLUDE-vTaskSuspend-和INCLUDE-vTaskResumeFromISR-都定义为1。-vTaskResumeFromISR-函数不能用于任务和中断的同步（因为中断随时可能出现）。" class="headerlink" title="FromISR：&#x3D;&#x3D;带FromISR后缀是在中断函数中专用的API&#x3D;&#x3D;。无论调用过多少次的任务挂起vTaskSuspend() ，只需要调用一次vTaskResumeFromISR()  即可解挂。&#x3D;&#x3D;使用该函数时，需要在FreeRTOSconfig.h中把INCLUDE_vTaskSuspend()和INCLUDE_vTaskResumeFromISR()  都定义为1。&#x3D;&#x3D;vTaskResumeFromISR()函数不能用于任务和中断的同步（因为中断随时可能出现）。 "></a><a href="#context.3">FromISR：&#x3D;&#x3D;带FromISR后缀是在中断函数中专用的API&#x3D;&#x3D;。无论调用过多少次的任务挂起vTaskSuspend() ，只需要调用一次vTaskResumeFromISR()  即可解挂。&#x3D;&#x3D;使用该函数时，需要在FreeRTOSconfig.h中把INCLUDE_vTaskSuspend()和INCLUDE_vTaskResumeFromISR()  都定义为1。&#x3D;&#x3D;vTaskResumeFromISR()函数不能用于任务和中断的同步（因为中断随时可能出现）。</a><a name="section.3"> </a></h6><p>  ​    vTaskSuspend(TaskHandle_t  vTaskSuspend) 形参为 vTaskSuspend，待挂起任务的任务句柄。注意：当传入的参数为NULL，则代表挂起任务自身（当前运行的任务）。<br>  ​    vTaskResume(TaskHandle_t  vTaskResume) 形参为vTaskResume，恢复指定任务的任务句柄。注意：任务无论被挂起多少次，只需要调用vTaskResume()恢复一次，就可以继续运行。且被恢复的任务进入到就绪态。<br>    &#x3D;&#x3D;BaseType_t&#x3D;&#x3D; xTaskResumeFromISR(TaskHandle_t  xTaskResume)  被标记的为函数的返回值类型，形参为xTaskResume，待恢复的任务句柄。返回值类型有两种：①pdTRUE ———任务恢复后需要进行任务切换 （&#x3D;&#x3D;进行任务切换的情况可能为进行抢占式调度，当前恢复的任务的优先级大于正在执行的任务的优先级&#x3D;&#x3D;）②pdFALSE———任务恢复后不需要进行任务切换。&#x3D;&#x3D;注意：中断服务程序中要调用FreeRTOS的API函数则中断优先级不能超过FreeRTOS所管理的最高优先级。&#x3D;&#x3D;</p>
<p>  ​               &#x3D;&#x3D;小知识点补充：任务优先级是数值越大优先级越高，中断优先级是数值越小优先级越高。&#x3D;&#x3D;</p>
<ol start="5">
<li><h2 id="中断管理"><a href="#中断管理" class="headerlink" title="中断管理"></a>中断管理</h2></li>
</ol>
<p>​           中断:让CPU打断正常运行的程序，转而去处理紧急的事件。中断属于异步异常。</p>
<p>​           异常：导致处理器脱离正常运行转向执行特殊代码的任何事件，如果不及时处理，轻则系统出错，重则导致系统瘫痪。异常分类： 同步异常和异步异常。有内部事件引起的异常叫做同步异常。异步异常主要指由外部异常源产生的异常。</p>
<p>​          中断执行机制：1.中断请求：外设产生中断请求（GPIO外部中断、定时器中断等）2.响应中断：CPU停止执行当前程序，转而去执行中断处理程序（ISR）3.退出中断：执行完毕，返回被打断的程序处，继续执行。</p>
<p>​         中断优先级分组设置：1.低于configMAX_SYSCALL_INTERRUPT_PRIORITY优先级的中断里才允许调用FreeRTOS的API函数<br>​                                                2.建议将所有优先级位指定为抢占优先级位，方便FreeRTOS管理。（调用函数HAL_NVIC_SePriorityGrouping(NVIC_PRIORITYGROUP_4）</p>
<p>​     三个系统中断优先级配置寄存器，分别为SHPR1、SHPR2、SHPR3，通过SHPR3将PendSV 和SysTick的中断优先级设置成最低优先级，保证系统任务切换不会阻塞系统其他中断的响应。</p>
<p>​    三个中断屏蔽寄存器，分别为PRIMASK、FAULTMASK、BASEPRI。FreeRTOS所使用的中断管理就是利用的BASEPRI寄存器，BASEPRI：屏蔽优先级低于某一个阈值的中断。</p>
<p>补充知识点：PendSV<strong>定义：</strong>可悬起异常，如果我们把它配置为最低<a href="https://so.csdn.net/so/search?q=%E4%BC%98%E5%85%88%E7%BA%A7&spm=1001.2101.3001.7020">优先级</a>，那么如果同时有多个异常被触发，他会再其他异常执行完毕后再执行，而且任何异常都可以打断它。systick<strong>定义</strong>（就是一个基于M3、M4内核的一个简单的24bit,倒计时,自动重装载定时器，倒计时结束会产生一个中断。常用于做延时，在实时系统中做心跳时钟，用于任务的切换。</p>
<p>​                                     1、systick定时器，就是系统滴答定时器</p>
<p>​                                    2、24位自动重装载倒计时定时器</p>
<p>​                                    3、当倒计时到0时，将从RELOAD寄存器中自动重装载初值</p>
<p>​                                   4、只要不清除SysTick控制及状态寄存器的使能位，就永不停息，在睡眠模式下也能工作</p>
<p>​                                    5、systick倒计时结束，会产生一个中断，且中断优先级可以设置</p>
<ol start="7">
<li><h2 id="临界段代码保护"><a href="#临界段代码保护" class="headerlink" title="临界段代码保护"></a>临界段代码保护</h2></li>
</ol>
<p> &#x3D;&#x3D;临界段代码也叫做临界区，是指那些必须完整运行，不能被打断的代码段。&#x3D;&#x3D;适用场合：①外设：需要严格按照时序初始化的外设；②系统：系统自身；③用户自身</p>
<p>FreeRTOS在进入临界段代码的时候需要关闭中断，当处理完临界段代码以后再打开中断。</p>
<p>临界段代码保护函数：<br>                              ①taskENTER_CRITICAL() ———任务级进入临界段（关中断）<br>                              ②taskEXIT_CRITICAL() ———任务级退出临界段（开中断）<br>                              ③taskENTER_CRITICAL_FROM_ISR() ———中断级进入临界段（关中断）<br>                              ④taskEXIT_CRITICAL_FROM_ISR() ———中断级退出临界段（开中断）</p>
<ol start="8">
<li><h2 id="任务调度器的挂起和恢复"><a href="#任务调度器的挂起和恢复" class="headerlink" title="任务调度器的挂起和恢复"></a>任务调度器的挂起和恢复</h2></li>
</ol>
<p>​       挂起任务调度器，调用此函数不需要关闭中断。</p>
<p>函数：①vTaskSuspendAll()  挂起任务调度器<br>           ②xTaskResumeAII()   恢复任务调度器</p>
<p>注意   1.与临界区不一样的是，挂起任务调度器，不需要关闭中断<br>           2.它仅仅是防止任务之间的资源争夺，中断照样可以直接响应；<br>           3.挂起调度器的方式，适用于临界区位于任务于任务之间，既不用去延时中断，又可以做到临界区的安全。</p>
<ol start="9">
<li><h2 id="FreeRTOS的列表和列表项"><a href="#FreeRTOS的列表和列表项" class="headerlink" title="FreeRTOS的列表和列表项"></a>FreeRTOS的列表和列表项</h2></li>
</ol>
<p>列表是FreeRTOS中的一个数据结构，概念上和链表类似，列表用来跟踪FreeRTOS中的任务。列表项就是放在列表中的项目。</p>
<p>列表根节点定义：<br><code>typedef struct xLIST</code></p>
<p><code>&#123;UBaseType_t uxNumberOfItems;</code>&#x2F;&#x2F;用于定于链表的节点计数器。用于表示该链表下有多少个节点，根节点除外。<br>   <code>ListItem_t * pxIndex;</code>&#x2F;&#x2F;链表节点索引指针，用于遍历节点。<br><code>MinListItem_t xListEnd;</code>&#x2F;&#x2F;链表的最后一个节点。<br><code>&#125;;</code></p>
<p>列表项：</p>
<p>​      <code>struct xLIST_ITEM</code><br><code>&#123;</code><br>​         <code>listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE        用于检测列表项的数据完整（未用到可以不看）</code></p>
<p>​        <code>configLIST_VOLATILE_TickType_t xltemValue          列表项的值</code><br>​        <code>struct xLIST_ITEM\*configLIST_VOLATILE  pxNext     下一个列表项</code><br>​        <code>struct xLIST_ITEM\*configLIST_VOLATILE  pxPrevious    上一个列表项</code><br>​        <code>void* pvOwner                                                                 列表项的拥有者</code><br>​        <code>struct xLIST_ITEM*configLIST_VOLATILE  pxContainer          列表项所在列表</code><br>​        <code>listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE                 用于检测列表项的数据完整性（未用到可以不看）</code></p>
<p><code>&#125;;</code></p>
<p>（1）成员变量xltemValue为列表项的值<br>（2）成员变量pxNext 、 pxPrevious表示列表中列表项下一个列表项和上一个列表项<br>（3）成员变量pvOwner用于指向包含列表项的对象<br>（4）成员变量pxContainer用于指向列表项所在的列表</p>
<p>迷你列表项：也是列表项，但迷你列表项仅用于标记列表的末尾和挂载在其他插入列表中的列表项。</p>
<pre><code>  struct xMINI_LIST_ITEM
</code></pre>
<p><code>&#123;</code><br>        <code>listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE         用于检测列表项的数据完整（未用到可以不看)</code><br>        <code>configLIST_VOLATILE_TickType_t xltemValue            列表项的值 </code></p>
<p><code>           struct xLIST_ITEM\*configLIST_VOLATILE  pxNext     下一个列表项</code><br>          <code>struct xLIST_ITEM\*configLIST_VOLATILE  pxPrevious    上一个列表项</code></p>
<p><code>&#125;</code>;</p>
<p>（1）成员变量xltemValue为列表项的值，这个值多用于按升序对列表中的列表项进行排序<br>（2）成员变量pxNext 、 pxPrevious表示列表中列表项下一个列表项和上一个列表项<br>（3）迷你列表项仅用于标记列表的末尾和挂载在其他插入列表中的列表项，因此不需要成员变量pvOwner和pxContainer，以节省内存开销。</p>
<ol start="10">
<li><h2 id="任务切换"><a href="#任务切换" class="headerlink" title="任务切换"></a>任务切换</h2></li>
</ol>
<p>任务切换的实质：就是CPU寄存器的切换。</p>
<p> 假设由任务A切换到任务B，主要分成两步：①需要暂停当前任务A的执行，并将此时任务A的寄存器保存到任务堆栈中，这个过程叫做任保存现场（压栈）。②将任务B的各个寄存器的值（被存于任务堆栈中）恢复到CPU寄存器中，这个过程叫做恢复现场（出栈）。对任务A的保存现场，任务B的恢复现场也叫做上下文切换。<br>注意：任务切换的过程在PendSV()中断服务函数里边完成。<br>             PendSV中断是如何触发的？（1）滴答定时器中断调用（2）执行FreeRTOS提供的相关API函数：portYIELD()。本质：通过向中断控制和状态寄存器ICSR（地址：0xE000_ED04）的bit写1挂起PendSV来启动PendSV中断。</p>
<ol start="11">
<li><h2 id="时间片调度"><a href="#时间片调度" class="headerlink" title="时间片调度"></a>时间片调度</h2></li>
</ol>
<p>使用时间片调度需要把宏configUSE_TIME_SLICING和configUSE_PREEMPTION置1。</p>
<p>时间统计API函数——void vTaskGetRunTimeStats(char* pcWriteBuffer)   此函数用于统计任务的运行时间，使用此函数需要将宏configGENERATE_RUN_TIME_STAT、configUSE_STATS_FORMATTING_FUNCTIONS置1。pcWriteBuffer接受任务运行时间信息的缓存指针。<br>时间统计API函数使用流程<br>（1）将宏configGENERATE_RUN_TIME_STAT置1.<br>（2）将宏configUSE_STATS_FORMATTING_FUNCTIONS置1.<br>（3）将宏configGENERATE_RUN_TIME_STAT置1后 ，还需要实现两个宏定义：①portCONFIGURE_TIME_FOR_RUNTIME_STATE():用于初始化用于配置任务运行时间统计的时基定时器；②portGET_RUN_TIME_COUNTER_VALUE():用于获取该功能时基硬件定时器计数的计数值。<br>延时函数：<br>        相对延时（vTaskDelay()）：指每次延时都是从执行函数vTaskDelay()开始，直到延时指定时间结束<br>        绝对延时（vTaskDelayUntil()）:指将整个任务的运行周期看成一个整体，适用于需要按照一定频率运行的任务。                      </p>
<ol start="12">
<li><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2></li>
</ol>
<p>队列又称为消息队列，队列可以在任务与任务之间、中断与任务之间传递信息，实现了任务接收来自于其他任务或中断的不固定长的数据。 任务能够从队列中读取消息，当队列中的消息为空时，读取消息的任务将被阻塞。</p>
<p>FreeRTOS中的队列的特点：<br> ①数据出入队方式：队列采用”先进先出“（FIFO）的数据存储缓冲机制，即先入队的数据会先从队列出来。<br> ②数据传递方式： FreeRTOS中队列采用实际值传递，即将数据拷贝到队列中进行传递，FreeRTOS采用拷贝数据传递，也可以传递指针，所以在传达较大的数据的时候采用指针传递。<br> ③多人任务访问：队列不属于任何某个认任务，任何任务和中断都可以向队列发送&#x2F;读取消息。<br> ④出队、入队阻塞：当任务向一个队列发送消息时，可以指定一个阻塞时间。<br>      入队阻塞：队列已满，此时写不进去数据。①将该任务的状态列表项挂载在pxDelayedTasksList()(阻塞任务列表);②将任务的事件列表项挂载在xTaskWaitingToSend()(等待发送列表)。<br>      出队阻塞：队列为空 ，此时读取不了数据。①将该任务的状态列表项挂载在pxDelayedTasksList()(阻塞任务列表)；②将任务的事件列表项挂载在xTasksWaitingToReceive(); 	</p>
<ol start="13">
<li><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2></li>
</ol>
<p>信号量是一种解决同步问题的机制，可以实现对共享资源的有序访问。是一种实现任务间通信的机制，可以实现任务之间同步或临界资源的互斥访问。&#x3D;&#x3D;信号量是一个非负的整数，&#x3D;&#x3D;所有获取它的任务都会将整数减一，当该整数值为0时，所有试图获取它的任务都将处于阻塞态。通常一个信号量的计数值用对应有效的资源数，表示剩下的可被占用的互斥资源数。</p>
<p>&#x3D;&#x3D;当计数值大于0时，代表有信号量资源；当释放信号量，信号量计数值加1；当任务获取信号量时，信号量计数值减1。&#x3D;&#x3D;</p>
<p>队列和信号量的区别：</p>
<table>
<thead>
<tr>
<th align="center">队列</th>
<th align="center">信号量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">可以容纳多个数据；创建队列有两部分内存：队列结构体（消息队列的控制块）、队列项存储空间（队头+队尾）</td>
<td align="center">仅存放计数值，无法存放其他数据；创建信号量，只需分配信号量的结构体</td>
</tr>
<tr>
<td align="center">写入队列：当队列满时，可阻塞；</td>
<td align="center">释放信号量：不可阻塞，计数值进行++；当计数值超过最大值时，返回失败</td>
</tr>
<tr>
<td align="center">读取队列：当队列没有数据时，可阻塞；</td>
<td align="center">获取信号量：计数值- -；当没有资源时，可以阻塞；</td>
</tr>
</tbody></table>
<p>二值信号量：本质上就是一个队列长度为1的队列，该队列就只有空和满两种情况。通常用于互斥访问或任务同步，与互斥信号量比较类似，但是二值信号量有可能会导致优先级翻转问题，二值信号量更适合用于任务同步，互斥信号量更适合用于临界资源的访问。<br>&#x3D;&#x3D;二值信号量和互斥信号量区别：互斥量有优先级继承机制，二值信号量没有这个机制。&#x3D;&#x3D;<br>在FreeRTOS中，信号量用于同步，如任务与任务的同步、中断与任务的同步，可以大大提高效率。</p>
<p>计数型信号量：本质上相当于队列长度大于1的队列，因此计数型信号量能够容纳多个资源，这个是在计数型信号量创建时确定的。<br>计数型信号量适用场合：①事件计数：当每次事件发生后，在事件处理函数中释放计数型信号量（计数值加1），其他任务会获计数型信号量（计数值减1），这个场合一般在创建时将初始计数值设置为0；②资源管理：信号量表示有效的资源数目。任务必须先获取信号量（信号量数值减1）才能获取资源控制权。当计数值减到0时，表示没有资源。当任务用完资源后，必须释放信号量（计数值加1）。信号量创建时计数值应等于最大资源数目。</p>
]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCodeTop100</title>
    <url>/2023/07/26/LeetCodeTop100/</url>
    <content><![CDATA[<h1 id="力扣TOP100"><a href="#力扣TOP100" class="headerlink" title="力扣TOP100"></a>力扣TOP100</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">哈希</a><a name="context.1"> </a></li>
<li><a href="#section.2">双指针</a><a name="context.2"> </a></li>
<li><a href="#section.3">滑动窗口</a><a name="context.3"> </a></li>
<li><a href="#section.4">子串</a><a name="context.4"> </a></li>
<li><a href="#section.5">数组</a><a name="context.5"> </a></li>
<li><a href="#section.6">矩阵</a><a name="context.6"> </a></li>
<li><a href="#section.7">链表</a><a name="context.7"> </a></li>
</ul>
<hr>
<span id="more"></span>

<p><a href="https://leetcode.cn/studyplan/top-100-liked/">LeetCode 热题 100 - 学习计划 - 力扣（LeetCode）全球极客挚爱的技术成长平台</a></p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希 "></a><a href="#context.1">哈希</a><a name="section.1"> </a></h2><p><a href="https://leetcode.cn/problems/two-sum/?envType=study-plan-v2&envId=top-100-liked">1. 两数之和 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</span></span><br><span class="line"><span class="comment">你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</span></span><br><span class="line"><span class="comment">你可以按任意顺序返回答案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [2,7,11,15], target = 9</span></span><br><span class="line"><span class="comment">输出：[0,1]</span></span><br><span class="line"><span class="comment">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [3,2,4], target = 6</span></span><br><span class="line"><span class="comment">输出：[1,2]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [3,3], target = 6</span></span><br><span class="line"><span class="comment">输出：[0,1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2 &lt;= nums.length &lt;= 104</span></span><br><span class="line"><span class="comment">-109 &lt;= nums[i] &lt;= 109</span></span><br><span class="line"><span class="comment">-109 &lt;= target &lt;= 109</span></span><br><span class="line"><span class="comment">只会存在一个有效答案</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; um;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = um.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (it != um.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    ret = &#123;it-&gt;second, i&#125;;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                um[nums[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-100-liked">49. 字母异位词分组 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</span></span><br><span class="line"><span class="comment">字母异位词 是由重新排列源单词的所有字母得到的一个新单词。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span></span><br><span class="line"><span class="comment">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: strs = [&quot;&quot;]</span></span><br><span class="line"><span class="comment">输出: [[&quot;&quot;]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: strs = [&quot;a&quot;]</span></span><br><span class="line"><span class="comment">输出: [[&quot;a&quot;]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= strs.length &lt;= 104</span></span><br><span class="line"><span class="comment">0 &lt;= strs[i].length &lt;= 100</span></span><br><span class="line"><span class="comment">strs[i] 仅包含小写字母</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!strs.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;string, vector&lt;string&gt;&gt; um;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> str: strs)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">string <span class="title">s</span><span class="params">(<span class="number">26</span>, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> c: str)</span><br><span class="line">                    ++s[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                </span><br><span class="line">                um[s].<span class="built_in">emplace_back</span>(str);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; it: um)</span><br><span class="line">                ret.<span class="built_in">emplace_back</span>(it.second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&envId=top-100-liked">128. 最长连续序列 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</span></span><br><span class="line"><span class="comment">请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [100,4,200,1,3,2]</span></span><br><span class="line"><span class="comment">输出：4</span></span><br><span class="line"><span class="comment">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [0,3,7,2,5,8,4,6,0,1]</span></span><br><span class="line"><span class="comment">输出：9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0 &lt;= nums.length &lt;= 105</span></span><br><span class="line"><span class="comment">-109 &lt;= nums[i] &lt;= 109</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">us</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> num: nums)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!us.<span class="built_in">count</span>(num - <span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> cur = num;</span><br><span class="line">                    <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (us.<span class="built_in">count</span>(++cur))</span><br><span class="line">                        ++size;</span><br><span class="line"></span><br><span class="line">                    ret = <span class="built_in">max</span>(ret, size);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针 "></a><a href="#context.2">双指针</a><a name="section.2"> </a></h2><p><a href="https://leetcode.cn/problems/move-zeroes/?envType=study-plan-v2&envId=top-100-liked">283. 移动零 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</span></span><br><span class="line"><span class="comment">请注意 ，必须在不复制数组的情况下原地对数组进行操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: nums = [0,1,0,3,12]</span></span><br><span class="line"><span class="comment">输出: [1,3,12,0,0]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: nums = [0]</span></span><br><span class="line"><span class="comment">输出: [0]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 104</span></span><br><span class="line"><span class="comment">-231 &lt;= nums[i] &lt;= 231 - 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; fast &lt; nums.<span class="built_in">size</span>(); ++fast)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[fast] != <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">swap</span>(nums[slow++], nums[fast]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/container-with-most-water/?envType=study-plan-v2&envId=top-100-liked">11. 盛最多水的容器 - 力扣（LeetCode）</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/image-20230808221705531.png" alt="image-20230808221705531"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</span></span><br><span class="line"><span class="comment">找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span></span><br><span class="line"><span class="comment">返回容器可以储存的最大水量。</span></span><br><span class="line"><span class="comment">说明：你不能倾斜容器。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：[1,8,6,2,5,4,8,3,7]</span></span><br><span class="line"><span class="comment">输出：49 </span></span><br><span class="line"><span class="comment">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：height = [1,1]</span></span><br><span class="line"><span class="comment">输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">n == height.length</span></span><br><span class="line"><span class="comment">2 &lt;= n &lt;= 105</span></span><br><span class="line"><span class="comment">0 &lt;= height[i] &lt;= 104</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (height.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                len = right - left;</span><br><span class="line">                ret = height[left] &gt; height[right]</span><br><span class="line">                      ? <span class="built_in">max</span>(ret, len * height[right--])</span><br><span class="line">                      : <span class="built_in">max</span>(ret, len * height[left++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/3sum/?envType=study-plan-v2&envId=top-100-liked">15. 3Sum - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</span></span><br><span class="line"><span class="comment">你返回所有和为 0 且不重复的三元组。</span></span><br><span class="line"><span class="comment">注意：答案中不可以包含重复的三元组。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [-1,0,1,2,-1,-4]</span></span><br><span class="line"><span class="comment">输出：[[-1,-1,2],[-1,0,1]]</span></span><br><span class="line"><span class="comment">解释：</span></span><br><span class="line"><span class="comment">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span></span><br><span class="line"><span class="comment">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span></span><br><span class="line"><span class="comment">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span></span><br><span class="line"><span class="comment">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span></span><br><span class="line"><span class="comment">注意，输出的顺序和三元组的顺序并不重要。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [0,1,1]</span></span><br><span class="line"><span class="comment">输出：[]</span></span><br><span class="line"><span class="comment">解释：唯一可能的三元组和不为 0 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [0,0,0]</span></span><br><span class="line"><span class="comment">输出：[[0,0,0]]</span></span><br><span class="line"><span class="comment">解释：唯一可能的三元组和为 0 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3 &lt;= nums.length &lt;= 3000</span></span><br><span class="line"><span class="comment">-105 &lt;= nums[i] &lt;= 105</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &gt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>, e = nums.<span class="built_in">size</span>() - <span class="number">2</span>; s &lt; e; ++s)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[s] &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; <span class="number">0</span> &amp;&amp; nums[s] == nums[s - <span class="number">1</span>])</span><br><span class="line">                    ;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> left = s + <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> sum;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">                    &#123;</span><br><span class="line">                        sum = nums[s] + nums[left] + nums[right];</span><br><span class="line">                        <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">                            --right;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">                            ++left;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            ret.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[s], nums[left], nums[right]&#125;);</span><br><span class="line">                            <span class="keyword">while</span> (++left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]);</span><br><span class="line">                            <span class="keyword">while</span> (left &lt; --right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/trapping-rain-water/?envType=study-plan-v2&envId=top-100-liked">42. 接雨水 - 力扣（LeetCode）</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/image-20230808221849426.png" alt="image-20230808221849426"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span></span><br><span class="line"><span class="comment">输出：6</span></span><br><span class="line"><span class="comment">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：height = [4,2,0,3,2,5]</span></span><br><span class="line"><span class="comment">输出：9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">n == height.length</span></span><br><span class="line"><span class="comment">1 &lt;= n &lt;= 2 * 104</span></span><br><span class="line"><span class="comment">0 &lt;= height[i] &lt;= 105</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (height.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>, hl = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> right = height.<span class="built_in">size</span>() - <span class="number">1</span>, hr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                hl = <span class="built_in">max</span>(hl, height[left]);</span><br><span class="line">                hr = <span class="built_in">max</span>(hr, height[right]);</span><br><span class="line">                ret += height[left] &gt; height[right] ? hr - height[right--] : hl - height[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口 "></a><a href="#context.3">滑动窗口</a><a name="section.3"> </a></h2><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/?envType=study-plan-v2&envId=top-100-liked">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;abcabcbb&quot;</span></span><br><span class="line"><span class="comment">输出: 3 </span></span><br><span class="line"><span class="comment">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;bbbbb&quot;</span></span><br><span class="line"><span class="comment">输出: 1</span></span><br><span class="line"><span class="comment">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;pwwkew&quot;</span></span><br><span class="line"><span class="comment">输出: 3</span></span><br><span class="line"><span class="comment">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span></span><br><span class="line"><span class="comment">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">0 &lt;= s.length &lt;= 5 * 104</span></span><br><span class="line"><span class="comment">s 由英文字母、数字、符号和空格组成</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (; fast &lt; s.<span class="built_in">size</span>(); ++fast)</span><br><span class="line">            &#123;</span><br><span class="line">                slow = <span class="built_in">max</span>(slow, arr[s[fast]]);</span><br><span class="line">                arr[s[fast]] = fast + <span class="number">1</span>;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, fast - slow + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked">438. 找到字符串中所有字母异位词 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</span></span><br><span class="line"><span class="comment">异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span></span><br><span class="line"><span class="comment">输出: [0,6]</span></span><br><span class="line"><span class="comment">解释:</span></span><br><span class="line"><span class="comment">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span></span><br><span class="line"><span class="comment">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;abab&quot;, p = &quot;ab&quot;</span></span><br><span class="line"><span class="comment">输出: [0,1,2]</span></span><br><span class="line"><span class="comment">解释:</span></span><br><span class="line"><span class="comment">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span></span><br><span class="line"><span class="comment">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。</span></span><br><span class="line"><span class="comment">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= s.length, p.length &lt;= 3 * 104</span></span><br><span class="line"><span class="comment">s 和 p 仅包含小写字母</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tar</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: p)</span><br><span class="line">            ++tar[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; fast &lt; s.<span class="built_in">size</span>(); ++fast)</span><br><span class="line">        &#123;</span><br><span class="line">            --tar[s[fast] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">while</span> (tar[s[fast] - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                ++tar[s[slow++] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fast - slow + <span class="number">1</span> == p.<span class="built_in">size</span>())</span><br><span class="line">                ret.<span class="built_in">emplace_back</span>(slow);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="子串"><a href="#子串" class="headerlink" title="子串 "></a><a href="#context.4">子串</a><a name="section.4"> </a></h2><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked">560. 和为 K 的子数组 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [1,1,1], k = 2</span></span><br><span class="line"><span class="comment">输出：2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [1,2,3], k = 3</span></span><br><span class="line"><span class="comment">输出：2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 2 * 104</span></span><br><span class="line"><span class="comment">-1000 &lt;= nums[i] &lt;= 1000</span></span><br><span class="line"><span class="comment">-107 &lt;= k &lt;= 107</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* 前缀 + 哈希 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; um;</span><br><span class="line">            <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">            um[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> n: nums)</span><br><span class="line">            &#123;</span><br><span class="line">                pre += n;</span><br><span class="line">                <span class="keyword">if</span> (um.<span class="built_in">count</span>(pre - k))</span><br><span class="line">                    ret += um[pre - k];</span><br><span class="line"></span><br><span class="line">                ++um[pre];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/sliding-window-maximum/?envType=study-plan-v2&envId=top-100-liked">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</span></span><br><span class="line"><span class="comment">返回 滑动窗口中的最大值 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span></span><br><span class="line"><span class="comment">输出：[3,3,5,5,6,7]</span></span><br><span class="line"><span class="comment">解释：</span></span><br><span class="line"><span class="comment">滑动窗口的位置                最大值</span></span><br><span class="line"><span class="comment">---------------               -----</span></span><br><span class="line"><span class="comment">[1  3  -1] -3  5  3  6  7       3</span></span><br><span class="line"><span class="comment"> 1 [3  -1  -3] 5  3  6  7       3</span></span><br><span class="line"><span class="comment"> 1  3 [-1  -3  5] 3  6  7       5</span></span><br><span class="line"><span class="comment"> 1  3  -1 [-3  5  3] 6  7       5</span></span><br><span class="line"><span class="comment"> 1  3  -1  -3 [5  3  6] 7       6</span></span><br><span class="line"><span class="comment"> 1  3  -1  -3  5 [3  6  7]      7</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">输入：nums = [1], k = 1</span></span><br><span class="line"><span class="comment">输出：[1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 105</span></span><br><span class="line"><span class="comment">-104 &lt;= nums[i] &lt;= 104</span></span><br><span class="line"><span class="comment">1 &lt;= k &lt;= nums.length</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 采用堆结构 priority_queue</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret.<span class="built_in">emplace_back</span>(pq.<span class="built_in">top</span>().first);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">                <span class="keyword">while</span> (pq.<span class="built_in">top</span>().second &lt;= i - k)</span><br><span class="line">                    pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                ret.<span class="built_in">emplace_back</span>(pq.<span class="built_in">top</span>().first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间复杂度：O(nlog⁡n)，其中 n 是数组 nums 的长度。在最坏情况下，数组 nums 中的元素单调递增，那么最终优先队列中包含了所有元素，没有元素被移除。由于将一个元素放入优先队列的时间复杂度为 O(log⁡n)，因此总时间复杂度为 O(nlog⁡n)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">空间复杂度：O(n)，即为优先队列需要使用的空间。这里所有的空间复杂度分析都不考虑返回的答案需要的 O(n) 空间，只计算额外的空间使用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 2: 单调栈 deque</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[dq.<span class="built_in">back</span>()])</span><br><span class="line">                    dq.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">                dq.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret.<span class="built_in">emplace_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[dq.<span class="built_in">back</span>()])</span><br><span class="line">                    dq.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">                dq.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">                <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() &lt;= i - k)</span><br><span class="line">                    dq.<span class="built_in">pop_front</span>();</span><br><span class="line">                </span><br><span class="line">                ret.<span class="built_in">emplace_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间复杂度：O(n)，其中 n 是数组 nums 的长度。每一个下标恰好被放入队列一次，并且最多被弹出队列一次，因此时间复杂度为 O(n)。</span></span><br><span class="line"><span class="comment">空间复杂度：O(k)，与方法一不同的是，在方法二中我们使用的数据结构是双向的，因此「不断从队首弹出元素」保证了队列中最多不会有超过 k+1 个元素，因此队列使用的空间为 O(k)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-100-liked">76. 最小覆盖子串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</span></span><br><span class="line"><span class="comment">如果 s 中存在这样的子串，我们保证它是唯一的答案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span></span><br><span class="line"><span class="comment">输出：&quot;BANC&quot;</span></span><br><span class="line"><span class="comment">解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：s = &quot;a&quot;, t = &quot;a&quot;</span></span><br><span class="line"><span class="comment">输出：&quot;a&quot;</span></span><br><span class="line"><span class="comment">解释：整个字符串 s 是最小覆盖子串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span></span><br><span class="line"><span class="comment">输出: &quot;&quot;</span></span><br><span class="line"><span class="comment">解释: t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span></span><br><span class="line"><span class="comment">因此没有符合条件的子字符串，返回空字符串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">m == s.length</span></span><br><span class="line"><span class="comment">n == t.length</span></span><br><span class="line"><span class="comment">1 &lt;= m, n &lt;= 105</span></span><br><span class="line"><span class="comment">s 和 t 由英文字母组成</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 滑动窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt;= t.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> need = <span class="number">0</span>;</span><br><span class="line">            unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; um;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c: t)</span><br><span class="line">            &#123;</span><br><span class="line">                --um[c];</span><br><span class="line">                ++need;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> slow = <span class="number">0</span>, fast, start;</span><br><span class="line">            <span class="type">int</span> min_size = INT_MAX;</span><br><span class="line">            deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">            <span class="keyword">while</span> (slow &lt; s.<span class="built_in">size</span>() &amp;&amp; !um.<span class="built_in">count</span>(s[slow])) ++slow;</span><br><span class="line">            <span class="keyword">for</span> (fast = slow; fast &lt; s.<span class="built_in">size</span>(); ++fast)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (um.<span class="built_in">count</span>(s[fast]))</span><br><span class="line">                &#123;</span><br><span class="line">                    need -= ++um[s[fast]] &lt;= <span class="number">0</span>;</span><br><span class="line">                    dq.<span class="built_in">emplace_back</span>(fast);</span><br><span class="line">                    <span class="keyword">while</span> (need == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fast - slow + <span class="number">1</span> &lt; min_size)</span><br><span class="line">                        &#123;</span><br><span class="line">                            start = slow;</span><br><span class="line">                            min_size = fast - slow + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (--um[s[slow]] &lt; <span class="number">0</span>)</span><br><span class="line">                            ++need;</span><br><span class="line"></span><br><span class="line">                        dq.<span class="built_in">pop_front</span>();</span><br><span class="line">                        slow = dq.<span class="built_in">front</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (min_size != INT_MAX)</span><br><span class="line">                ret = s.<span class="built_in">substr</span>(start, min_size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="数组"><a href="#数组" class="headerlink" title="数组 "></a><a href="#context.5">数组</a><a name="section.5"> </a></h2><p><a href="https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked">53. 最大子数组和 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span></span><br><span class="line"><span class="comment">子数组 是数组中的一个连续部分。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span></span><br><span class="line"><span class="comment">输出：6</span></span><br><span class="line"><span class="comment">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [1]</span></span><br><span class="line"><span class="comment">输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [5,4,-1,7,8]</span></span><br><span class="line"><span class="comment">输出：23</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 105</span></span><br><span class="line"><span class="comment">-104 &lt;= nums[i] &lt;= 104</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 动规（无后效性）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ret = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> num: nums) &#123;</span><br><span class="line">                pre = <span class="built_in">max</span>(pre + num, num);</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, pre);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked">56. 合并区间 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/rotate-array/?envType=study-plan-v2&envId=top-100-liked">189. 轮转数组 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-100-liked">238. 除自身以外数组的乘积 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/first-missing-positive/description/">41. 缺失的第一个正数 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。</span></span><br><span class="line"><span class="comment">请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [1,2,0]</span></span><br><span class="line"><span class="comment">输出：3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [3,4,-1,1]</span></span><br><span class="line"><span class="comment">输出：2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [7,8,9,11,12]</span></span><br><span class="line"><span class="comment">输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 5 * 105</span></span><br><span class="line"><span class="comment">-231 &lt;= nums[i] &lt;= 231 - 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 在元素组上哈希</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ret = nums.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span>)</span><br><span class="line">                    nums[i] = nums.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="type">int</span> num = <span class="built_in">abs</span>(nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= nums.<span class="built_in">size</span>()) <span class="comment">///&lt; num [1, N]</span></span><br><span class="line">                    nums[num - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[num - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ret = i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵 "></a><a href="#context.6">矩阵</a><a name="section.6"> </a></h2><p><a href="https://leetcode.cn/problems/set-matrix-zeroes/description/?envType=study-plan-v2&envId=top-100-liked">73. 矩阵置零 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/spiral-matrix/?envType=study-plan-v2&envId=top-100-liked">54. 螺旋矩阵 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span></span><br><span class="line"><span class="comment">输出：[1,2,3,6,9,8,7,4,5]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span></span><br><span class="line"><span class="comment">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">m == matrix.length</span></span><br><span class="line"><span class="comment">n == matrix[i].length</span></span><br><span class="line"><span class="comment">1 &lt;= m, n &lt;= 10</span></span><br><span class="line"><span class="comment">-100 &lt;= matrix[i][j] &lt;= 100</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!matrix.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> d = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++i) ret.<span class="built_in">emplace_back</span>(matrix[u][i]);</span><br><span class="line">                <span class="keyword">if</span> (++u &gt; d)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt;= d; ++i) ret.<span class="built_in">emplace_back</span>(matrix[i][r]);</span><br><span class="line">                <span class="keyword">if</span> (--r &lt; l)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = r; i &gt;= l; --i) ret.<span class="built_in">emplace_back</span>(matrix[d][i]);</span><br><span class="line">                <span class="keyword">if</span> (--d &lt; u)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = d; i &gt;= u; --i) ret.<span class="built_in">emplace_back</span>(matrix[i][l]);</span><br><span class="line">                <span class="keyword">if</span> (++l &gt; r)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/rotate-image/description/?envType=study-plan-v2&envId=top-100-liked">48. 旋转图像 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</span></span><br><span class="line"><span class="comment">你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span></span><br><span class="line"><span class="comment">输出：[[7,4,1],[8,5,2],[9,6,3]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span></span><br><span class="line"><span class="comment">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">n == matrix.length == matrix[i].length</span></span><br><span class="line"><span class="comment">1 &lt;= n &lt;= 20</span></span><br><span class="line"><span class="comment">-1000 &lt;= matrix[i][j] &lt;= 1000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!matrix.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u = <span class="number">0</span>, d = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, r = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = l, j = u; i &lt; r; ++i, ++j)</span><br><span class="line">                    <span class="built_in">swap</span>(matrix[u][i], matrix[j][r]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = l, j = r; i &lt; r; ++i, --j)</span><br><span class="line">                    <span class="built_in">swap</span>(matrix[u][i], matrix[d][j]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = l, j = d; i &lt; r; ++i, --j)</span><br><span class="line">                    <span class="built_in">swap</span>(matrix[u][i], matrix[j][l]);</span><br><span class="line"></span><br><span class="line">                ++u;</span><br><span class="line">                --d;</span><br><span class="line">                ++l;</span><br><span class="line">                --r;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/?envType=study-plan-v2&envId=top-100-liked">240. 搜索二维矩阵 II - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</span></span><br><span class="line"><span class="comment">每行的元素从左到右升序排列。</span></span><br><span class="line"><span class="comment">每列的元素从上到下升序排列。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5</span></span><br><span class="line"><span class="comment">输出：true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20</span></span><br><span class="line"><span class="comment">输出：false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">m == matrix.length</span></span><br><span class="line"><span class="comment">n == matrix[i].length</span></span><br><span class="line"><span class="comment">1 &lt;= n, m &lt;= 300</span></span><br><span class="line"><span class="comment">-109 &lt;= matrix[i][j] &lt;= 109</span></span><br><span class="line"><span class="comment">每行的所有元素从左到右升序排列</span></span><br><span class="line"><span class="comment">每列的所有元素从上到下升序排列</span></span><br><span class="line"><span class="comment">-109 &lt;= target &lt;= 109</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 矩阵向左旋转45度，转换为BST树(二叉搜索树)，左树小，右树大</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!matrix.<span class="built_in">empty</span>() &amp;&amp; matrix[<span class="number">0</span>][<span class="number">0</span>] &lt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> col = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;  <span class="comment">///&lt; 列</span></span><br><span class="line">            <span class="type">int</span> row = <span class="number">0</span>;  <span class="comment">///&lt; 行</span></span><br><span class="line">            <span class="keyword">while</span> (col &gt;= <span class="number">0</span> &amp;&amp; row &lt; matrix.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[row][col] &lt; target)</span><br><span class="line">                    ++row;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &gt; target)</span><br><span class="line">                    --col;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ret = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="链表"><a href="#链表" class="headerlink" title="链表 "></a><a href="#context.7">链表</a><a name="section.7"> </a></h2><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&envId=top-100-liked">160. 相交链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">listA 中节点数目为 m</span></span><br><span class="line"><span class="comment">listB 中节点数目为 n</span></span><br><span class="line"><span class="comment">1 &lt;= m, n &lt;= 3 * 104</span></span><br><span class="line"><span class="comment">1 &lt;= Node.val &lt;= 105</span></span><br><span class="line"><span class="comment">0 &lt;= skipA &lt;= m</span></span><br><span class="line"><span class="comment">0 &lt;= skipB &lt;= n</span></span><br><span class="line"><span class="comment">如果 listA 和 listB 没有交点，intersectVal 为 0</span></span><br><span class="line"><span class="comment">如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 双指针，两条路各走一遍</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *ret = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (headA &amp;&amp; headB)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *pa = headA, *pb = headB;</span><br><span class="line">            <span class="keyword">while</span> (pa != pb)</span><br><span class="line">            &#123;</span><br><span class="line">                pa = pa == <span class="literal">nullptr</span> ? headB : pa-&gt;next;</span><br><span class="line">                pb = pb == <span class="literal">nullptr</span> ? headA : pb-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret = pa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/reverse-linked-list/description/?envType=study-plan-v2&envId=top-100-liked">206. 反转链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：head = [1,2,3,4,5]</span></span><br><span class="line"><span class="comment">输出：[5,4,3,2,1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 三指针赋值 pre cur next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *ret = <span class="literal">nullptr</span>, *next;</span><br><span class="line">        <span class="keyword">while</span>  (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next = head-&gt;next;</span><br><span class="line">            head-&gt;next = ret;</span><br><span class="line">            ret = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/palindrome-linked-list/description/?envType=study-plan-v2&envId=top-100-liked">234. 回文链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">链表中节点数目在范围[1, 105] 内</span></span><br><span class="line"><span class="comment">0 &lt;= Node.val &lt;= 9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 存vector转用双指针法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                arr.<span class="built_in">emplace_back</span>(head-&gt;val);</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (head != <span class="literal">nullptr</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> r = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] == arr[r])</span><br><span class="line">            &#123;</span><br><span class="line">                ++l;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ret = l &gt;= r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 2: 快慢指针 + 反转链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">Reverse</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 已知非空，故不做判断</span></span><br><span class="line">        ListNode *ret = <span class="literal">nullptr</span>, *next;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next = head-&gt;next;</span><br><span class="line">            head-&gt;next = ret;</span><br><span class="line">            ret = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *fast = head;</span><br><span class="line">            ListNode *slow = head;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast-&gt;next-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ListNode *temp = fast-&gt;next ? fast-&gt;next : fast;</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;val == temp-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                slow-&gt;next = <span class="built_in">Reverse</span>(slow-&gt;next);</span><br><span class="line">                <span class="keyword">while</span> (temp != <span class="literal">nullptr</span> &amp;&amp; head-&gt;val == temp-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = temp-&gt;next;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                ret = temp == <span class="literal">nullptr</span>;</span><br><span class="line">                slow-&gt;next = <span class="built_in">Reverse</span>(slow-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/linked-list-cycle/description/?envType=study-plan-v2&envId=top-100-liked">141. 环形链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个链表的头节点 head ，判断链表中是否有环。</span></span><br><span class="line"><span class="comment">如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</span></span><br><span class="line"><span class="comment">如果链表中存在环 ，则返回 true 。 否则，返回 false 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">进阶：你能用 O(1)（即，常量）内存解决此问题吗？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 快慢指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *fast = head-&gt;next;</span><br><span class="line">            ListNode *slow = head;</span><br><span class="line">            <span class="keyword">while</span> (fast != slow &amp;&amp; fast)</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast-&gt;next ? fast-&gt;next-&gt;next : fast-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret = fast != <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/?envType=study-plan-v2&envId=top-100-liked">142. 环形链表 II - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</span></span><br><span class="line"><span class="comment">如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</span></span><br><span class="line"><span class="comment">不允许修改 链表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">进阶：你是否可以使用 O(1) 空间解决此题？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 哈希表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *ret = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_set&lt;ListNode *&gt; us;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!us.<span class="built_in">count</span>(head))</span><br><span class="line">                &#123;</span><br><span class="line">                    us.<span class="built_in">emplace</span>(head);</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ret = head;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (head);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 2: 快慢指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *ret = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (head != fast)</span><br><span class="line">                &#123;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ret = head;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/?envType=study-plan-v2&envId=top-100-liked">21. 合并两个有序链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">两个链表的节点数目范围是 [0, 50]</span></span><br><span class="line"><span class="comment">-100 &lt;= Node.val &lt;= 100</span></span><br><span class="line"><span class="comment">l1 和 l2 均按 非递减顺序 排列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 暴力(略)</span></span><br><span class="line"><span class="comment">///&lt; Method 2: 循环迭代 + 智能指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_ptr&lt;ListNode&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> ListNode())</span></span>;</span><br><span class="line">        ListNode *pre = ptr.<span class="built_in">get</span>();</span><br><span class="line">        <span class="keyword">while</span> (list1 &amp;&amp; list2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pre-&gt;next = list1 ? list1 : list2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI七层传输协议模型</title>
    <url>/2023/09/01/OSI%E4%B8%83%E5%B1%82%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="OSI七层传输协议模型"><a href="#OSI七层传输协议模型" class="headerlink" title="OSI七层传输协议模型"></a>OSI七层传输协议模型</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">1. 应用层（Application Layer）</a><a name="context.1"> </a></li>
<li><a href="#section.2">2. 表示层（Presentation Layer）</a><a name="context.2"> </a></li>
<li><a href="#section.3">3. 会话层（Session Layor）</a><a name="context.3"> </a></li>
<li><a href="#section.4">4. 传输层（Transport Layer）</a><a name="context.4"> </a></li>
<li><a href="#section.5">5. 网络层（Network Layer）</a><a name="context.5"> </a></li>
<li><a href="#section.6">6. 数据链路层（Data Link Layer）</a><a name="context.6"> </a></li>
<li><a href="#section.7">7. 物理层（Physical Layer）</a><a name="context.7"> </a></li>
</ul>
<hr>
<p>​        &#x3D;&#x3D;为了完成不同计算机或网络或架构之间的成功通信，国际标准化组织提出了OSI七层模型，该模型(从上到下)包括了应用层、表示层、会话层、传输层、网络层、数据链路层、物理层&#x3D;&#x3D;。</p>
<img src="C:\Users\倪瑞\AppData\Roaming\Typora\typora-user-images\image-20230901144204611.png" alt="image-20230901144204611" style="zoom: 80%;" />

<p>​        &#x3D;&#x3D;每一层其实际上都是一个协议包&#x3D;&#x3D;，比如说当我们要提起应用层的时候，并不仅仅指计算机的应用程序（谷歌、火狐等APP），还包含了大量的应用层协议，应用层协议能使应用层程序在网络中够正确的运行，记下来我们一起来看下OSI的七层模型。</p>
<h3 id="1-应用层（Application-Layer）"><a href="#1-应用层（Application-Layer）" class="headerlink" title="1. 应用层（Application Layer） "></a><a href="#context.1">1. 应用层（Application Layer）</a><a name="section.1"> </a></h3><p>​         应用层是由网络应用程序使用的，离用户最近的一层。应用层通过各种协议（FTP——文件传输协议；HTTP&#x2F;S——网上冲浪协议；SMTP——邮件传输协议；Telnet——与虚拟端之间的通信协议），为网络应用提供服务（网络应用是指使用会互联网的计算机应用），&#x3D;&#x3D;<strong>执行用户活动</strong>&#x3D;&#x3D;。</p>
<img src="https://pic3.zhimg.com/v2-f9bba83371f1c5e1f6dc038121874616_r.jpg" alt="img" style="zoom:80%;" />

<h3 id="2-表示层（Presentation-Layer）"><a href="#2-表示层（Presentation-Layer）" class="headerlink" title="2. 表示层（Presentation Layer） "></a><a href="#context.2">2. 表示层（Presentation Layer）</a><a name="section.2"> </a></h3><p>表示层从应用层接受数据，这些数据是以字符和数字的形式出现的（如：Chinese、666），表示层将这些字符和数据，转换成机器能够理解的二进制格式（1001 0110），&#x3D;&#x3D;表示层的这个功能称为“翻译”功能，即把人类的语言翻译成机器能理解的语言&#x3D;&#x3D;。在传输数据之前，表示层减少了用来表示原始数据的比特数，也就是将原始数据进行了压缩，数据压缩减少了数据原始数据所需的空间，随着文件大小的减少，它就可以在很短的时间内到达目的地，数据压缩对实时视频和音频传输有很大的帮助，以保持完整性的数据传输前的数据加密。</p>
<img src="https://pic1.zhimg.com/v2-cf8307be4afee49b6bcb661c3494ffc8_r.jpg" alt="img" style="zoom:80%;" />

<p>与此同时，&#x3D;&#x3D;在发送端，数据会在表示层被加密，然后在接受端，数据再在表示层进行解密操作，保证数据传输的安全型&#x3D;&#x3D;。</p>
<img src="https://pic3.zhimg.com/v2-c892fedc700269c1109bb35d61317ad2_r.jpg" alt="img" style="zoom:80%;" />

<h3 id="3-会话层（Session-Layor）"><a href="#3-会话层（Session-Layor）" class="headerlink" title="3. 会话层（Session Layor） "></a><a href="#context.3">3. 会话层（Session Layor）</a><a name="section.3"> </a></h3><p>​         在讲会话层之前，我们首先假设下，如果你计划办一个聚会，为确保每一个活动能顺利进行，则需要建立一个流程（装扮环境、烧菜、清洁、告别）。</p>
<p>​          会话层的情况也是如此，会话层用于建立和管理连接、启用、发送和连接数据，就像你为聚会雇用助手一样，会话层也有自己的助手，也就是各种API或应用程序接口，还有NetBIOS，即网络基本输入输出系统，它允许不同计算机上的应用程序相互通信。</p>
<img src="https://pic3.zhimg.com/v2-1ba9a4d55bc1e256cabc483b2db0792a_r.jpg" alt="img" style="zoom:80%;" />

<p>在客户端与服务器建立会话之前，服务器会执行一项为身份验证的功能，比如你在客户端计算机输入了用户名和密码之后（指向服务器应用程序对于的API），客户端计算机和服务器之间将建立会话或链接。</p>
<img src="https://pic1.zhimg.com/v2-9352a9270c4b8b6b3ccdfe6170a1f8d4_r.jpg" alt="img" style="zoom:80%;" />

<p>​        通过身份验证后，服务器将检查用户授权身份验证和授权，授权是服务器来确定你是否有访问文件权限的过程，如果服务器确认你所登录的账号没有相应的权限，则客户端计算机就会收到一条消息，告诉你：您未被授权访问此页面。</p>
<p>​        &#x3D;&#x3D;身份验证和授权这两个功能都由会话层执行，会话层提供正在下载的文件的跟踪&#x3D;&#x3D;。举个例子，我们上网浏览的网页包含了文本、图片等信息，这些文本和图片作为单独的文件存储在Web服务器上，当你在Web浏览器中请求网站时，你的Web浏览器将建立一个到Web服务器的单独会话，以便分别下载这些文本和图像信息文件。这些文件以数据包的形式被接收，与此同时，会话层也给出了下载下来的那个数据包属于哪个文件的轨迹，以确定是文本文件还是图像文件，并追踪他们收到数据包的位置，最终将文本和图片展示在浏览器中，这个就是会话层的会话管理功能。到这里，我们也知道了，浏览器会执行应用层、表示层和会话层所有的功能。</p>
<img src="https://pic1.zhimg.com/v2-f5b86cebae9d9ca24f670aeccdf0f030_r.jpg" alt="img" style="zoom:80%;" />

<p>&#x3D;&#x3D;总结一下，会话层有三个方面的功能：会话管理、会话管理和授权&#x3D;&#x3D;。</p>
<img src="https://pic1.zhimg.com/v2-56fb685108ab139605830dc347ca61d0_r.jpg" alt="img" style="zoom:80%;" />

<h3 id="4-传输层（Transport-Layer）"><a href="#4-传输层（Transport-Layer）" class="headerlink" title="4. 传输层（Transport Layer） "></a><a href="#context.4">4. 传输层（Transport Layer）</a><a name="section.4"> </a></h3><p>在会话层之下时传输层。传输层通过分段（Segmentation）、流量控制（Flow Control）和差错控制（Error Control）来控制通信的可靠性。</p>
<p>（1）首先在分段中，传输层从会话层接收数据，并将数据分为称为“段”（Segment）的数据单元：</p>
<img src="C:\Users\倪瑞\AppData\Roaming\Typora\typora-user-images\image-20230901145649183.png" alt="image-20230901145649183" style="zoom:50%;" />

<p>​         且每个数据单元（Data Unit）包含一个源端口号、目的端口号和序列号，</p>
<img src="https://pic3.zhimg.com/v2-51462f4237cf8c9a72cf7c0389c8801e_r.jpg" alt="img" style="zoom:80%;" />

<p>这些端口号有助于引导每一个网段执行正确的应用程序。</p>
<img src="https://pic2.zhimg.com/v2-a6ce88ff998a90672721a5143b71d185_r.jpg" alt="img" style="zoom:80%;" />

<p>（2）其次，在流量控制中，传输层可以控制传输的数据量。假如一个移动设备连接到一个服务器，若服务器的最大可以传输100Mbps的数据，而我们移动端设备最大可以处理10Mbps的数据，现在我们正在从服务器下载一个文件，但是服务器开始以50Mbs的速度发送数据，这比手机所能处理的速率要高，所以手机在传输层的帮助下，可以告诉服务器将数据传输速率降低到10Mbps，这样就不会有数据丢失。</p>
<img src="https://pic1.zhimg.com/v2-e06668381b5fc9aefb2c5991648ae3c0_r.jpg" alt="img" style="zoom:80%;" />

<p>（3）最后一个是差错控制。传输层也可用于差错控制，在数据传输的过程中，如果某些数据出现丢失，目标传输层将使用自动重复请求方案，来重新传输丢失或损坏的数据，传输层向每个段添加一个称为“校验和”的位，以找出所接收到的传输层控制协议。</p>
<img src="https://pic3.zhimg.com/v2-3dfb1b1238417dfc39fb35bddc397f7e_r.jpg" alt="img" style="zoom:80%;" />

<p>传输层控制协议有面向连接的传输和面向无连接的传输，面向连接的传输通过TCP来实现的面向无连接的传输是通过UDP来实现的。</p>
<img src="https://pic1.zhimg.com/v2-e24e713962fb63616bb093c44e81517c_r.jpg" alt="img" style="zoom:80%;" />

<p>UDP比TCP更快，因为它不会提供任何关于数据是否真正交付的反馈，而TCP提供反馈，因此丢失的数据可以在TCP中重新传输。在是否接收到所有的数据并不重要的应用场景中，如流媒体电源、歌曲、游戏、IP语音、TFTP、DNS等可以使用UDP协议传输数据；而必须要进行完整的数据传输的场合，例如万维网、电子邮件、FTP等，就需要使用TCP协议。</p>
<p>&#x3D;&#x3D;总结一下，传输层涉及到分段（Segmentation）、流量控制（Flow Control）、差错控制（Error Control）、面向连接（TCP）和无连接（UDP）的传输&#x3D;&#x3D;。</p>
<h3 id="5-网络层（Network-Layer）"><a href="#5-网络层（Network-Layer）" class="headerlink" title="5. 网络层（Network Layer） "></a><a href="#context.5">5. 网络层（Network Layer）</a><a name="section.5"> </a></h3><p>传输层将数据传递到网络层，网络层用于将接收到的数据段从一台计算机传输到不同网络中的另一台计算机，网络层的数据单元称为数据包（Packets），网络层的功能是进行逻辑寻址（Logical Addressing）、路由（Rout）和路径确定（Path Determination）。</p>
<img src="https://pic1.zhimg.com/v2-2b03009d119e245d9923a25ea9b3181c_r.jpg" alt="img" style="zoom:80%;" />

<p>（1）首先是逻辑寻址（Logical Addressing）。在网络层进行的IP寻址称为逻辑寻址，网络中每一台计算机都有一个唯一的IP地址，网络层为每一个分段（Segment）都会被分配发送方和接收方的IP地址，并形成一个IP数据包，分配IP地址是为了确保每一个数据包到达正确的目的地。</p>
<img src="https://pic1.zhimg.com/v2-9c5adadd09422e84b486cff00e1bb7b4_r.jpg" alt="img" style="zoom:80%;" />

<p>（2）路由（Rout）。路由是一种将数据包从源端移动到目的端的方法，该方法建立子啊IPV4 &amp; IPV6基础之上。</p>
<img src="https://pic4.zhimg.com/v2-f0334aaeee4b3e31563a042a975efe3b_r.jpg" alt="img" style="zoom:80%;" />

<p>现假如计算机A与网络1相连，计算机B与网络2相连，我们从B电脑请求访问Facebook网站，现在有了来自计算机B中Facebook服务器的回复，这些回复将以数据包的形式出现，而这个数据包只传送到计算机B，由于网络中每个设备都有一个唯一的IP地址，所以计算机A和计算机B都也有一个唯一的IP地址，而Facebook服务器给计算机B的回复已经在数据包中，且在数据包中已经添加了发送方的IP地址：192.168.3.1和接收方的IP地址192.168.2.1，假设子网掩码使用255.255.255.0，这个掩码表示IP地址的前三组数字代表网络，即计算机B所在的网段（Network 2）就是192.168.2，而IP地址的最后一个数就是计算机的编号，这样我们就可以采用IP地址和掩码的方式在网络层进程数据的传输。</p>
<img src="https://pic4.zhimg.com/v2-13a3b3b4290eee0f277e4d8c9fa55eb3_r.jpg" alt="img" style="zoom:80%;" />

<p>（3）接下来就是路径选择（Path Determination）的问题，计算机可以通过多种方式连接到Internet服务器，从源到目标的数据传递的最佳可能路径称为“路径选择”，关于路径选择的协议有OSPF、边界网关协议（BGP）、中间系统到中间系统协议（IS-IS），以确定数据传递的最佳可能路径。</p>
<img src="https://pic1.zhimg.com/v2-3a8631f027f9810e20c0c5753cec52f8_r.jpg" alt="img" style="zoom:80%;" />

<h3 id="6-数据链路层（Data-Link-Layer）"><a href="#6-数据链路层（Data-Link-Layer）" class="headerlink" title="6. 数据链路层（Data Link Layer） "></a><a href="#context.6">6. 数据链路层（Data Link Layer）</a><a name="section.6"> </a></h3><p>&#x3D;&#x3D;数据链路层从网络层接收数据包，数据包包含了发送方和接受方的IP地址。有两种寻址方式：逻辑寻址和物理寻址&#x3D;&#x3D;。逻辑寻址在网络层已经完成，即在数据段（Segment）中添加了发送方和接收方的IP地址，以形成IP数据包。而物理寻址就是在数据链路层中完成的，其方法就是在IP数据包中添加发送方计算机和接收方计算机的物理地址：MAC，从而形成一个数据帧。MAC地址是由计算机制造商嵌入到计算机的，也是唯一的，我们的手机也有一个唯一的MAC地址。</p>
<img src="https://pic4.zhimg.com/v2-bec211c8eab3dcf7ea8e8742c46a16c7_r.jpg" alt="img" style="zoom:80%;" />

<p>数据链路层中的数据单元称为“帧”数据，链路层作为计算机的软件网络接口卡嵌入，网卡提供经由本地介质将数据从一台计算机传送到另一台计算机的装置，本地介质包括铜线、光纤或无线电信号。</p>
<img src="https://pic2.zhimg.com/v2-9f6282593f731095c8b01599ba5ad3f1_r.jpg" alt="img" style="zoom:80%;" />

<p>所以，数据链路层执行两个基本功能：1.允许上层使用“帧封装”之类的各种技术访问介质；2.控制如何放置和接收来自介质的数据，并进行错误检测。</p>
<p>有时候可能会有多个设备连接到公共介质，如果两个或多个设备连接到同一个介质，并同时发送数据，那么这些消息可能会发生冲突，从而形成一个收件人无法理解的信息，为了避免这些情况，数据链路层会密切关注，并监视什么时候共享的媒介是空闲的，这样设备就可以为接收端传递正确的数据，这就是所谓的CSMA（载波监听多路访问）技术。</p>
<img src="https://pic1.zhimg.com/v2-08c27e18439ac2e7bdf0f773c9c92c34_r.jpg" alt="img" style="zoom:80%;" />

<h3 id="7-物理层（Physical-Layer）"><a href="#7-物理层（Physical-Layer）" class="headerlink" title="7. 物理层（Physical Layer） "></a><a href="#context.7">7. 物理层（Physical Layer）</a><a name="section.7"> </a></h3><p>到现在为止，应用的“行为动作”已经通过传输层进行了分割，变成网络层的数据包和数据链路层的数据“帧”，现在是一种二进制序列了，最后在物理层将这些二进制序列转换成信号并在本地介质（铜缆、光纤、无线信号等）上传输，并在目标计算机应用层上显示数据。</p>
<img src="https://pic3.zhimg.com/v2-1969916e8bb505609bcfa87aca5ca5a2_r.jpg" alt="img" style="zoom:80%;" />]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>1.markdown语法</title>
    <url>/2023/08/27/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="markdown语法"><a href="#markdown语法" class="headerlink" title="markdown语法"></a>markdown语法</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">1.1快捷键</a><a name="context.1"> </a></li>
<li><a href="#section.2">1.2文字(文本)显示</a><a name="context.2"> </a></li>
<li><a href="#section.3">2.1无序列表</a><a name="context.3"> </a></li>
<li><a href="#section.4">2.2有序列表</a><a name="context.4"> </a></li>
<li><a href="#section.5">2.3任务列表</a><a name="context.5"> </a></li>
<li><a href="#section.6">4.1行内代码</a><a name="context.6"> </a></li>
<li><a href="#section.7">4.2代码块</a><a name="context.7"> </a></li>
</ul>
<hr>
<h2 id="1-1快捷键"><a href="#1-1快捷键" class="headerlink" title="1.1快捷键 "></a><a href="#context.1">1.1快捷键</a><a name="section.1"> </a></h2><table>
<thead>
<tr>
<th>名称</th>
<th>语法</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>标题</td>
<td>用#表示，#一级标题，##二级标题，以此类推</td>
<td>ctrl+1&#x2F;2&#x2F;3&#x2F;4     ctrl+0快速将文本调整成普通文本     ctrl+加号&#x2F;减号对标题级别进行加减</td>
</tr>
<tr>
<td>字体加粗</td>
<td>用** **包裹起来</td>
<td>ctrl+B</td>
</tr>
<tr>
<td>斜体字</td>
<td>用* *包裹起来</td>
<td>ctrl+L</td>
</tr>
<tr>
<td>加粗斜体</td>
<td>用*** ***包裹起来</td>
<td>ctrl+B  &#x2F; ctrl+L</td>
</tr>
<tr>
<td>删除线</td>
<td>用~~ ~~ 包裹起来</td>
<td>shift+atl+5</td>
</tr>
<tr>
<td>下划线</td>
<td>用<u> <u>包裹起来</td>
<td>ctrl+U</td>
</tr>
<tr>
<td>引用</td>
<td>在文字开头添加&gt;表示引用说明</td>
<td>ctrl+Q</td>
</tr>
<tr>
<td>高亮</td>
<td>用&#x3D;&#x3D; &#x3D;&#x3D;包裹起来</td>
<td>无快捷键</td>
</tr>
<tr>
<td>插入表格</td>
<td></td>
<td>ctrl+T</td>
</tr>
<tr>
<td>在表格下方插入一行</td>
<td></td>
<td>ctrl+enter</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-2文字-文本-显示"><a href="#1-2文字-文本-显示" class="headerlink" title="1.2文字(文本)显示 "></a><a href="#context.2">1.2文字(文本)显示</a><a name="section.2"> </a></h2><ol>
<li>上下标：</li>
</ol>
<p>​     <code>x^2^</code></p>
<p>​    <code>H~2~O</code></p>
<p>效果：</p>
<p>​    x^2^</p>
<p>   H<del>2</del>O</p>
<p>2.文本居中</p>
<p>代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;center&gt;内容&lt;/kbd&gt;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<center>内容</kbd>

<p>3.快捷键显示<br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;kbd&gt;内容&lt;/kbd&gt;</span><br></pre></td></tr></table></figure>

<p>效果：<br><kbd>内容</kbd></p>
<p>4.加粗<br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;b&gt;加粗&lt;/b&gt;</span><br></pre></td></tr></table></figure>

<p>效果：<br><b>加粗</b></p>
<p>4.倾斜<br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;i&gt;倾斜&lt;/i&gt;</span><br></pre></td></tr></table></figure>

<p>效果：<i>倾斜</i></p>
<p>5.上下标<br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开始&lt;sup&gt;123hi你好&lt;/sup&gt;</span><br><span class="line">开始&lt;sub&gt;321hi你好&lt;/sub&gt;</span><br></pre></td></tr></table></figure>

<p>效果：<br>开始<sup>123hi你好</sup><br>开始<sub>321hi你好</sub></p>
<h2 id="2-列表"><a href="#2-列表" class="headerlink" title="2.列表"></a>2.列表</h2><h3 id="2-1无序列表"><a href="#2-1无序列表" class="headerlink" title="2.1无序列表 "></a><a href="#context.3">2.1无序列表</a><a name="section.3"> </a></h3><p>代码：</p>
<p> <code>*/-/+ + 空格</code></p>
<p>效果：</p>
<p>1.只有同一级别：</p>
<ul>
<li><p>1</p>
</li>
<li><p>2</p>
</li>
<li><p>3</p>
<p>  2.子集类</p>
<ul>
<li>1<ul>
<li>2<ul>
<li>3</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>  快捷键：ctrl+shift+]</p>
</li>
</ul>
<h3 id="2-2有序列表"><a href="#2-2有序列表" class="headerlink" title="2.2有序列表 "></a><a href="#context.4">2.2有序列表</a><a name="section.4"> </a></h3><p>代码：</p>
<p><code>数字+.+空格</code></p>
<p>效果：</p>
<ol>
<li><p>第一个标题</p>
</li>
<li><p>第二个标题</p>
</li>
<li><p>第三个标题</p>
<ul>
<li>子内容1</li>
<li>子内容2</li>
</ul>
</li>
<li><p>第四个标题<br> 快捷键为ctrl+shift+[</p>
</li>
</ol>
<h3 id="2-3任务列表"><a href="#2-3任务列表" class="headerlink" title="2.3任务列表 "></a><a href="#context.5">2.3任务列表</a><a name="section.5"> </a></h3><pre><code>代码：

`- [ ]吃早饭`

`- [x]背单词`
效果：

- [ ] 吃早饭

- [ ] 背单词
</code></pre>
<p>快捷键：ctrl+shift+x</p>
<h2 id="3-区块显示"><a href="#3-区块显示" class="headerlink" title="3.区块显示"></a>3.区块显示</h2><p>代码：</p>
<p><code>&gt;+回车</code></p>
<p>效果：</p>
<blockquote>
<p>这是最外层代码块</p>
<blockquote>
<p>这是内层代码块</p>
</blockquote>
<blockquote>
<blockquote>
<p>这是最内层代码块</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="代码显示"><a href="#代码显示" class="headerlink" title="代码显示"></a>代码显示</h2><h3 id="4-1行内代码"><a href="#4-1行内代码" class="headerlink" title="4.1行内代码 "></a><a href="#context.6">4.1行内代码</a><a name="section.6"> </a></h3><p>代码：</p>
<p><code>int a=0;</code></p>
<p>快捷键：ctrl+shift+&#96;</p>
<h3 id="4-2代码块"><a href="#4-2代码块" class="headerlink" title="4.2代码块 "></a><a href="#context.7">4.2代码块</a><a name="section.7"> </a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//输出 cout</span><br><span class="line">//输入 cin</span><br></pre></td></tr></table></figure>

<p>快捷键：ctrl+shift+K</p>
<h2 id="5-链接"><a href="#5-链接" class="headerlink" title="5.链接"></a>5.链接</h2><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">www.baidu,com</span><br><span class="line">[百度](https://www.baidu.com)</span><br><span class="line">[百度])(https://www.baidu.com &quot;https://www.baidu.com&quot;)</span><br></pre></td></tr></table></figure>

<p>效果：<br><a href="https://www.baidu.com/">百度</a><br>[百度])(<a href="https://www.baidu.com/">https://www.baidu.com</a> “<a href="https://www.baidu.com/">https://www.baidu.com</a>“)</p>
<h2 id="6-脚注"><a href="#6-脚注" class="headerlink" title="6.脚注"></a>6.脚注</h2><p>对文本进行解释说明<br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[^文本]</span><br><span class="line">[^文本]：解释说明</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p>​    c++<a href="%E8%BF%99%E6%98%AF%E4%B8%80%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">^①</a></p>
<p>c<a href="%E8%BF%99%E6%98%AF%E4%B8%80%E7%A7%8D%E7%AE%80%E5%8D%95%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">^②</a></p>
<h2 id="7-插入图片"><a href="#7-插入图片" class="headerlink" title="7.插入图片"></a>7.插入图片</h2><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![不显示的文字]（图片路径 &quot;图片标题&quot;）</span><br></pre></td></tr></table></figure>


<p>效果：<img src="/"></p>
<p>快捷键：ctrl+shift+I</p>
<h2 id="8-表格"><a href="#8-表格" class="headerlink" title="8.表格"></a>8.表格</h2><p>快捷键：</p>
<p>插入表格：ctrl+T<br>在最后一行添加一行表格：ctrl+enter<br>在一行表格里面再添加一行：shift+enter</p>
<h2 id="9-流程图"><a href="#9-流程图" class="headerlink" title="9.流程图"></a>9.流程图</h2><h2 id="10-表情符号"><a href="#10-表情符号" class="headerlink" title="10.表情符号"></a>10.表情符号</h2><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:happy: /:cry: /:man:</span><br></pre></td></tr></table></figure>

<p>效果：<br>:happy: &#x2F;:cry: &#x2F;:man:</p>
]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/09/03/%E5%B0%8F%E7%B1%B3%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>小米笔试题目：</p>
<p>1.一套程序既可以在多个不同的操作系统上运行，最主要的原因是：</p>
<p>​    A.在不同操作系统上，编译该程序的工具使用了GNU编译器，GNU是一个标准“GUN   compiler Collection”的缩写。这个标准确保了程序在各种操作都能实现数值理解和计算的一致性。<br>​	B.该程序使用了与操作系统无关的虚拟机技术，例如JAVA虚拟机或.NET，这些虚拟机技术将程序的执行与特定操作系统的细节分离，使得程序可以在不同操作系统上运行。<br>​	C.该程序使用了跨平台开发语言，如C++或Java，这些语言在不同操作系统上具有其对应的运行环境，从而实现了不同操作系统上的可移植性。<br>​	D.在不同操作系统上，该程序源代码使用了相同的字符编码，例如ISO-8859-1或者UFT-8。这使得无论是在Linux还是Windows环境下，都能够正确的解释和处理程序中的文本内容。</p>
<p>2.使用小米手机，我们可以打开音乐ap听歌的同时打开moba游戏娱乐。为了实现听歌的同时可以打开游戏，操作系统对此提供最关键技术是？</p>
<p>​	A.操作系统为应用提供“中断处理”和“任务代理执行”技术，在MOBA游戏打开时将音乐播任务放入内核服务器中代理执行并响应新任务中断开启MOBA游戏运行。<br>​	B.操作系统使用虚拟化技术与CS架构，将音乐app和MOBA游戏运行在不同的虚拟机中运行，并以统一服务的形式接受二者的声音数据画面在服务器操作混音播放和图层渲染。<br>​	C.操作系统将CPU时间分割成小的时间片，每个应用程序依次执行一个时间片，实现多个应用程序轮流执行。<br>​	D.操作系统通过创建多个独立的CPU核心，每个应用程序分配到一个独立的核心：使得多个应用程序可以正真同时并行执行。</p>
<p>3.下列关于数据库的说法错误的是？</p>
<p>​	A.一个事务执行过程中，其正在访问的数据被其他事务所修改，导致处理结果不正确，这是由于违背了事务的原子性而引起的。<br>​	B.sql语言中删除视图使用delete命令。<br>​	C.一张表只能有一个主键，但可以有多个唯一索引。<br>​	D.数据库设计范式的引入，提高了数据库访问的效率。</p>
<p>4.以下哪些是面向对象编程中常见的设计原则？</p>
<p>​	A.依赖倒置原则<br>​	B.六度分隔原则<br>​	C.单一职责原则<br>​	D.开放封闭原则</p>
<p>5.操作系统其中的一条主要工作是对硬件的管理，例如给手机插入了一条有线耳机，该耳机能够被正确识别到会涉及到：</p>
<p>A.DMA<br>B.ADC<br>C.IRQ<br>D.RPC</p>
<p>6.当在浏览器输入<a href="https://www.mi.com,从按下回车到显示小米官网的过程中,正确的是/">https://www.mi.com，从按下回车到显示小米官网的过程中，正确的是</a></p>
<p>A.通过DNS解析，找到对应的IP地址和端口号<br>B.向服务器发送HTTP请求报文，并收到响应报文<br>C.完成数据传输后，TCP三次挥手断开与服务器的连接<br>D.TCP四次握手与服务器建立连接，以进行数据传输</p>
<p>7.以下的4种说法，错误的包括</p>
<p>A.在大顶堆的二叉树中，第N层中的所有元素比第N+1层中的所有元素都要大。<br>B.已知一棵二叉树的前序遍历顺序和后序遍历顺序，可以唯一确定这棵二叉树。<br>C.将一个递归算法改为非递归算法时，通常使用队列作为辅助结构。<br>D.数组利用下标定位，时间复杂度为O（1），链表定位元素时间复杂度O（n）。</p>
<p>8.关于IP地址描述正确的有</p>
<p>​	A.B类IP地址不能以127开头<br>​	B.同一网络上的每台主机必须有相同的网络ID才能互相通信<br>​	C.B类IP地址不能全为1或全为0<br>​	D.同一网络上的每台主机必须分配有唯一的主机ID</p>
<p>9.以下哪些是软件测试的常见类型</p>
<p>A.集成测试<br>B.验收测试<br>C.单元测试<br>D.性能测试</p>
<p>10.如果一个任务执行需要占用CPU 40% 的时间，同时需要进行长时间的I&#x2F;O操作，该任务运行时间为100秒，那么在单核CPU下要完成两次该任务的CPU占用率，I&#x2F;O时间以及最短需要多长时间?</p>
<p>​	A.CPU实际占用率为40%，IO占用时间为 60秒，最短需要100秒。<br>​	B.CPU实际占用率为80%，IO占用时间为 60秒，最短需要140秒。<br>​	C.CPU实际占用率为80%，IO占用时间为120秒，最短需要120秒。<br>​	D.CPU实际占用率为40%、10 占用时间为120秒，最短需要200秒。</p>
<p>11.对于一个共有M个结点、N条边的森林，共有几棵树?</p>
<p>​	A.M-N<br>​	B.M-N+1<br>​	C.不能确定<br>​	D.M-N-1</p>
<p>12.在面向对象编程中，关于抽象类(Abstract Class)定义正确的是?</p>
<p>​	A.抽象类是一种只包会具体方法的类<br>​	B.抽象类是可以被直接实例化的类<br>​	C.抽象类是一种只包会抽象方法的类<br>​	D.抽象类是一种可以被经承的类，但不能被直接实例化</p>
<p>13.在SELECT语句中，使用关键字0)可以把重复行屏蔽</p>
<p>​	A.DISTINCT<br>​	B.UNION<br>​	C.TOP<br>​	D.ALL</p>
<p>14.已知现有一个大小为4初始状态为空的栈，现在有一组字母经过这个栈后，最终的字母顺序是:BEDAC，问原始的进栈数据不可能是下的哪组?</p>
<p>​	A.ADEBC<br>​	B.EBADC<br>​	C.DACEB<br>​	D.EBCAD</p>
<p>15.在面向对象编程中，封装的作用是什么?</p>
<p>​	A.提供数据访问权限控制<br>​	B.实现多态性<br>​	C.提高程序执行效率<br>​	D.实现代码的复用</p>
<p>16.在软件工程中，UML(统一建模语言)用于什么?</p>
<p>​	A.进行需求分析和设计<br>​	B.进行软件测试和优化<br>​	C.进行项目管理和团队协作<br>​	D.进行编码和调试</p>
<p>17.小米手机生产过程中会经过严苛的测试环节，其中包括手机通讯功能中的射频校准。射频校准会打点数据上报到云端。其中包含两组数据:第一组数据中会包合此次校准的频道号(freg)信息第二短会上传一批数据，包含一组频道号(freq)和其对应的损失值(oss)，其中这一组频道号(treo)不会重复，且是有序的。现在雾要根据第一组数据中的频道号(freg)，找到离第二组中频道号(freq)最近的那一个freq对应的loss值，如果两边一样近，则取两边loss的平均主掉入为int，输出为double类型四会五入保留1位小数)</p>
<p>输入描述：<br>包含两组数据：<br>    第一组数据中会包含此次校准的频道号（freq）信息。<br>    第二组会上传一批数据，包含一组频道号（freq）和其对应的损失值（loss），其中这一组频道号（freq）不会重复，且是有序的。</p>
<p>输出描述：<br>      输出频道号最近的对应的loss值。如果两边一样接近，则取两边loss的平均值。</p>
<p>样例输入：<br>        2800<br>1950：10，2000：15，3000：9</p>
<p>样例输出：<br>        9.0</p>
<p>18.8月份发布会一结束，米小免就在公司领到了一台最新发布的Xiaomi MIX Fold 3手机，这是款小米旗舰折喜屏手机，并搭载了全新升级架构的MIU114系统。其先进的应用引擎不仅让系统更流场，应用体验也大幅提升。<br>在一个优化项中，为了尽可能提升用户白天使用手机的体验和续航，某些已经在系统中注册过的任务会被设置为空闲任务，仅在手机空闲时运行(比如数据备份或AI相册整理)。现在系统中注册了若干坦空闲任务，每个任务有各自的耗电量以及允许任务运行的最低初始电量，我们需要计算手机影移里行完成全部任务的最低初始电量。<br>注营点1:所有电量以mAh(毫安时)计，Xiaomi MiX Fold 3的大电池容量是4800mAh。<br>注意点2，本题目假设手机在运行空闲任务期间，不处于充电状态，也没有额外耗电行为。<br>注意点3、智能应用肇会以最合适的顺序串行运行任务。</p>
<p>输入描述：<br>        一个描述了所有任务的长字符串。任务与任务之间使用逗号分隔，每组任务由耗电量及最低初始电量组成，用冒号隔开。</p>
<p>输出描述：<br>一个数字，代表依次完成全部任务的最低初始电量，如果最低初始电量超过手机电池容量，则返回-1。</p>
<p>样例输入：<br>    1：10，2：12，3：10</p>
<p>样例输出：<br>     13</p>
]]></content>
  </entry>
  <entry>
    <title>嵌入式八股文</title>
    <url>/2023/08/29/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%85%AB%E8%82%A1%E6%96%87/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="嵌入式八股文"><a href="#嵌入式八股文" class="headerlink" title="嵌入式八股文"></a>嵌入式八股文</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">芯片选型考虑哪些因素？</a><a name="context.1"> </a></li>
<li><a href="#section.2">STM32F4和F1的区别，为什么选用F4？</a><a name="context.2"> </a></li>
<li><a href="#section.3">STM32启动过程：</a><a name="context.3"> </a></li>
<li><a href="#section.4">stm32的定时器</a><a name="context.4"> </a></li>
<li><a href="#section.5">stm32的AD采样</a><a name="context.5"> </a></li>
<li><a href="#section.6">Linux嵌入式和单片机嵌入式区别：</a><a name="context.6"> </a></li>
<li><a href="#section.7">FreeRTOS、μC&#x2F;OS的区别</a><a name="context.7"> </a></li>
<li><a href="#section.8">在RTOS中，二值信号量和互斥量的区别？</a><a name="context.8"> </a></li>
<li><a href="#section.9">在RTOS中，任务通知的运行机制是怎么样的？</a><a name="context.9"> </a></li>
<li><a href="#section.10">UCOS任务调度</a><a name="context.10"> </a></li>
<li><a href="#section.11">UCOS中任务间的通信</a><a name="context.11"> </a></li>
<li><a href="#section.12">STM32 中断是怎么进入到中断服务程序的</a><a name="context.12"> </a></li>
<li><a href="#section.13">UCOS中断处理过程</a><a name="context.13"> </a></li>
<li><a href="#section.14">DMA有什么用</a><a name="context.14"> </a></li>
<li><a href="#section.15">处理器与外部设备通信的两种方式</a><a name="context.15"> </a></li>
<li><a href="#section.16">串行通信的通信方式</a><a name="context.16"> </a></li>
<li><a href="#section.17">串行通信分为</a><a name="context.17"> </a></li>
<li><a href="#section.18">Modbus通讯协议</a><a name="context.18"> </a></li>
<li><a href="#section.19">485通讯的原理</a><a name="context.19"> </a></li>
<li><a href="#section.20">RS485和RS232的区别</a><a name="context.20"> </a></li>
<li><a href="#section.21">串口通信协议UART</a><a name="context.21"> </a></li>
<li><a href="#section.22">串口异步通信</a><a name="context.22"> </a></li>
<li><a href="#section.23">SPI（串行外围设备接口）</a><a name="context.23"> </a></li>
<li><a href="#section.24">SPI是什么？有几条线？几种模式？</a><a name="context.24"> </a></li>
<li><a href="#section.25">IIC</a><a name="context.25"> </a></li>
<li><a href="#section.26">CAN通信介绍</a><a name="context.26"> </a></li>
<li><a href="#section.27">传输速度</a><a name="context.27"> </a></li>
</ul>
<hr>
<h2 id="芯片选型考虑哪些因素？"><a href="#芯片选型考虑哪些因素？" class="headerlink" title="芯片选型考虑哪些因素？ "></a><a href="#context.1">芯片选型考虑哪些因素？</a><a name="section.1"> </a></h2><ol>
<li>性能：确保芯片具有足够的处理能力来满足项目需求。</li>
<li>内存：选择具有足够RAM和ROM（或Flash）容量的芯片。</li>
<li>能耗：根据项目要求，权衡功耗和性能。</li>
<li>外设和接口：选择支持所需通信协议和设备连接的芯片。</li>
<li>封装和尺寸：考虑空间限制和生产要求，选择合适的封装类型。</li>
<li>开发工具和支持：选用具有良好文档和支持的芯片，降低开发难度。</li>
<li>供应和成本：确保稳定供应并选择性价比合适的芯片。</li>
<li>软件和生态系统：选择具有成熟软件支持和丰富生态系统的芯片。</li>
<li>安全性：根据项目要求，选择具有相应安全功能的芯片。</li>
<li>可扩展性：选择具有一定可扩展性和升级能力的芯片，以适应项目需求变化。</li>
</ol>
<h2 id="STM32F4和F1的区别，为什么选用F4？"><a href="#STM32F4和F1的区别，为什么选用F4？" class="headerlink" title="STM32F4和F1的区别，为什么选用F4？ "></a><a href="#context.2">STM32F4和F1的区别，为什么选用F4？</a><a name="section.2"> </a></h2><p>内核不同：F1是Cortex-M3内核，F4是Cortex-M4内核；</p>
<p>主频不同：F1主频72MHz，F4主频168MHz；</p>
<p>浮点运算：F1无浮点运算单位没有硬件FPU处理浮点数运算，F4有；</p>
<p>（没有浮点加速硬件FPU只影响浮点计算的速度，并不是不能计算浮点数，因此只能通过内核的软件进行计算。先要把这个浮点数运算转换成定点数存储，再把这个定点数转换成指数的方式进行运算，不仅中间要进行数据转换，并且要进行多次移位，而整数型就不需要这么复杂的操作，直接运算就可以，所以F1浮点数运算不仅运算量大并且会加大MCU的负载，要慢很多）</p>
<p>功能性能：F4外设比F1丰富且功能更强大，比如GPIO翻转速率、上下拉电阻配置、ADC精度等；</p>
<p>内存大小：F1内部SRAM最大64K，F4有192K(112+64+16)。</p>
<p>F4的RAM和ROM：ram192K，rom大小2048K</p>
<p>考虑到需要浮点运算和使用RTOS系统，最后选择F4；</p>
<h2 id="STM32启动过程："><a href="#STM32启动过程：" class="headerlink" title="STM32启动过程： "></a><a href="#context.3">STM32启动过程：</a><a name="section.3"> </a></h2><ol>
<li>复位向量表（Reset Vector Table）：在STM32微控制器中，复位向量表是一个存储器区域，其中包含了处理器在复位时跳转执行的第一条指令的地址。通常，复位向量表位于存储器的起始地址，由芯片制造商预先定义。复位向量表的内容包括复位中断处理函数、中断向量表和其他初始化函数。</li>
<li>处理器复位：当STM32芯片上电或者外部复位信号触发时，处理器的复位引脚将会被拉低，导致处理器执行复位操作。在复位期间，处理器会将各个寄存器的值初始化为默认值，并开始执行复位向量表中的第一条指令。</li>
<li>系统初始化：复位向量表中的第一条指令通常是一条跳转指令，将控制权转移到系统初始化函数的地址上。系统初始化函数主要用于设置处理器和系统的一些基本配置，例如时钟源和时钟频率的配置，初始化堆栈指针、全局变量等。</li>
<li>C库初始化：在系统初始化完成后，通常会调用C库的初始化函数。C库的初始化函数主要是对C语言运行环境的初始化，包括清零BSS段（未初始化的全局变量）、复制数据段（初始化的全局变量）等。</li>
<li>主函数入口：C库初始化完成后，处理器将跳转到主函数的入口地址开始执行用户程序。主函数是程序的入口点，其中包含应用程序的具体逻辑。</li>
</ol>
<p>需要注意的是，上述步骤是一般情况下的启动流程，具体的启动过程可能会因不同的芯片型号、启动模式和编译器设置而有所差异。此外，还可以通过修改复位向量表的内容来实现特定的启动操作，例如自定义复位中断处理函数或添加其他初始化函数。</p>
<h2 id="stm32的定时器"><a href="#stm32的定时器" class="headerlink" title="stm32的定时器 "></a><a href="#context.4">stm32的定时器</a><a name="section.4"> </a></h2><p>提问定时器相关的，具体根据你个人开发使用情况解答。</p>
<ol>
<li>定时器时钟使能：首先，需要使能所需的定时器时钟。这可以通过RCC（Reset and Clock Control）寄存器来配置。例如，如果要使用TIM2定时器，需要使能TIM2的时钟。</li>
<li>定时器配置：配置定时器的基本参数，例如计数器的工作模式、时钟分频系数、计数器的自动重载值等。这些配置可以通过定时器的相关寄存器进行设置。</li>
<li>定时器中断设置（可选）：如果需要使用定时器中断，可以配置中断源和中断优先级，并使能定时器中断。</li>
<li>启动定时器：配置完成后，启动定时器开始计数。定时器可以通过软件触发或外部触发来启动计数。</li>
<li>定时器中断处理（可选）：如果配置了定时器中断，当计数器达到设定的值时，会触发中断。在中断服务程序中可以执行相应的操作，例如更新计数器的值、处理中断标志等。</li>
</ol>
<h2 id="stm32的AD采样"><a href="#stm32的AD采样" class="headerlink" title="stm32的AD采样 "></a><a href="#context.5">stm32的AD采样</a><a name="section.5"> </a></h2><p>提问AD采样相关的，具体根据你个人开发使用情况解答。</p>
<ol>
<li>ADC配置：首先，需要配置ADC模块的相关寄存器，包括时钟使能、采样时间、采样通道等。这些配置可以通过寄存器操作或者使用STM32提供的库函数进行设置。</li>
<li>GPIO配置：为了使用ADC，需要将相应的GPIO引脚配置为模拟输入模式，并使能相应的ADC通道。这可以通过配置GPIO寄存器来完成。</li>
<li>触发方式设置：可以选择触发ADC转换的方式，例如软件触发或外部触发。如果选择外部触发，还需要配置相关的触发源和极性。</li>
<li>ADC转换：在进行ADC转换之前，可以设置ADC分辨率、对齐方式、连续转换模式等。然后，可以通过启动转换命令或触发源来开始ADC转换。</li>
<li>中断或轮询获取结果：可以选择使用中断或轮询的方式获取ADC转换结果。如果使用中断方式，可以在转换完成后触发中断，并在中断服务程序中读取转换结果。如果使用轮询方式，则需要在转换完成后主动查询并读取转换结果。</li>
<li>结果处理：获取到ADC转换结果后，可以根据需要进行相应的处理，例如数据转换、单位换算等。</li>
</ol>
<h2 id="Linux嵌入式和单片机嵌入式区别："><a href="#Linux嵌入式和单片机嵌入式区别：" class="headerlink" title="Linux嵌入式和单片机嵌入式区别： "></a><a href="#context.6">Linux嵌入式和单片机嵌入式区别：</a><a name="section.6"> </a></h2><p>复杂性：Linux嵌入式系统是基于Linux内核构建的，具有完整的操作系统功能，包括多任务处理、文件系统、网络协议等。相比之下，单片机嵌入式系统通常使用裸机编程或者实时操作系统（RTOS），具有更简单的系统结构和功能。</p>
<p>处理能力：Linux嵌入式系统通常在较强大的处理器上运行，例如ARM、x86等，具备较高的处理能力和存储容量。而单片机嵌入式系统使用单片机芯片，其处理能力和存储容量较低。</p>
<p>开发环境：Linux嵌入式系统使用标准的开发工具链和开发环境，可以使用高级编程语言（如C&#x2F;C++）进行开发，并且具备广泛的软件支持和开发社区。单片机嵌入式系统的开发通常需要使用特定的单片机编程工具和汇编语言，开发资源相对较少。</p>
<p>系统定制性：Linux嵌入式系统具有很高的可定制性，可以根据应用需求选择所需的软件组件和功能，并且支持模块化的软件开发和更新。单片机嵌入式系统的定制性相对较低，往往需要在设计阶段确定所需功能和硬件配置。</p>
<p>成本和功耗：Linux嵌入式系统由于使用较高性能的处理器和较大容量的存储器，相对而言成本较高，并且功耗较高。单片机嵌入式系统由于采用低成本、低功耗的单片机芯片，成本较低且功耗较低。</p>
<p>总的来说，Linux嵌入式系统适用于需要复杂功能、较高性能和较大存储容量的应用，如智能手机、平板电脑、网络设备等。而单片机嵌入式系统适用于资源有限、功耗要求低、对实时性要求较高的应用，如传感器、家电、汽车电子等。</p>
<h2 id="FreeRTOS、μC-OS的区别"><a href="#FreeRTOS、μC-OS的区别" class="headerlink" title="FreeRTOS、μC&#x2F;OS的区别 "></a><a href="#context.7">FreeRTOS、μC&#x2F;OS的区别</a><a name="section.7"> </a></h2><p>开源性质：FreeRTOS是一个开源的RTOS，可以免费获取并在商业和非商业项目中使用。它具有广泛的用户社区和支持。而μC&#x2F;OS是一种商业RTOS，需要购买许可证才能使用。</p>
<p>架构和内核：FreeRTOS采用基于优先级的抢占式内核架构，支持多任务处理、时间片轮转调度和中断服务机制。它提供了一套轻量级的内核函数和任务管理机制。μC&#x2F;OS也是基于优先级的抢占式内核，但它提供了更多的功能，如事件标志、信号量、消息邮箱等，以满足更复杂的应用需求。</p>
<p>资源占用：FreeRTOS的内核非常小巧，具有低的存储器占用和快速的上下文切换速度，适用于资源有限的嵌入式系统。μC&#x2F;OS相对而言具有更大的内核代码大小和更高的存储器占用，但它提供了更丰富的功能和可选组件。</p>
<p>硬件平台支持：FreeRTOS在多种处理器架构上都有支持，包括ARM、MIPS、x86等，因此它适用于广泛的硬件平台。μC&#x2F;OS也支持多种处理器架构，但支持的硬件平台较少，且主要集中在微控制器和嵌入式系统上。</p>
<p>社区支持和生态系统：由于FreeRTOS的开源性质，它具有庞大的用户社区和广泛的生态系统，提供了丰富的示例代码、开发工具和支持资源。μC&#x2F;OS作为商业RTOS，其用户社区和生态系统相对较小，但有专门的技术支持和服务。</p>
<h2 id="在RTOS中，二值信号量和互斥量的区别？"><a href="#在RTOS中，二值信号量和互斥量的区别？" class="headerlink" title="在RTOS中，二值信号量和互斥量的区别？ "></a><a href="#context.8">在RTOS中，二值信号量和互斥量的区别？</a><a name="section.8"> </a></h2><p>二值信号量是一种计数器，只有两种状态：0和1。当一个任务试图获取一个已经被获取的二值信号量时，该任务会被挂起，直到该信号量被释放为止。二值信号量通常用于同步任务的开始或者结束，或者是保护共享资源的读写等。由于二值信号量不具有优先级继承功能，当高优先级任务等待低优先级任务释放二值信号量时，低优先级任务可能会优先执行，导致任务调度出现问题。</p>
<p>互斥量也是一种计数器，但它具有更多的状态。当一个任务获取一个已经被获取的互斥量时，该任务会被挂起，并且该互斥量的计数器会减一。只有当计数器归零时，该互斥量才会被释放。互斥量通常用于保护共享资源的读写等，它具有优先级继承功能，可以避免高优先级任务因为等待低优先级任务释放互斥量而被阻塞的问题。</p>
<h2 id="在RTOS中，任务通知的运行机制是怎么样的？"><a href="#在RTOS中，任务通知的运行机制是怎么样的？" class="headerlink" title="在RTOS中，任务通知的运行机制是怎么样的？ "></a><a href="#context.9">在RTOS中，任务通知的运行机制是怎么样的？</a><a name="section.9"> </a></h2><ol>
<li>发送任务向接收任务发送通知，通知包括通知值和接收任务的句柄。</li>
<li>接收任务准备好接收通知，并在等待通知列表中等待通知的到来。</li>
<li>发送任务调用发送通知的API函数，RTOS将通知保存到接收任务的等待通知列表中。</li>
<li>如果接收任务已经准备好接收通知，那么RTOS会将该任务从等待通知列表中移除，并唤醒该任务继续执行。</li>
<li>如果接收任务没有准备好接收通知，那么该任务会继续等待，直到接收任务准备好接收通知。</li>
</ol>
<h2 id="UCOS任务调度"><a href="#UCOS任务调度" class="headerlink" title="UCOS任务调度 "></a><a href="#context.10">UCOS任务调度</a><a name="section.10"> </a></h2><p>一个任务，也称作一个线程。</p>
<p>UCOS有一个任务调度机制，根据任务的优先级进行调度。</p>
<p>一个是硬件中断， 那么系统会将当前任务有关变量入栈，然后执行中断服务程序，执行完成后出栈返回.</p>
<p>另一个是任务之间的切换，使用的方法就是任务调度，每一个任务有自己的栈，顺度也是一样的入栈，然后执行另一个程序，然后出线返回。</p>
<p>并非是每一任务按优先级顺序轮流执行的，而是高优先级的任务独占运行，除非其主动放弃执行，否则低优先级任务不能抢占，同时高优先级可以把放出去给低优先级任务使用的CPU占用权抢回来。所以UCOS的任务间要注意插入等待延时，以便UCOS切出去让低优先级任务执行。</p>
<h2 id="UCOS中任务间的通信"><a href="#UCOS中任务间的通信" class="headerlink" title="UCOS中任务间的通信 "></a><a href="#context.11">UCOS中任务间的通信</a><a name="section.11"> </a></h2><p>在UCOS中，是使用信号量、邮箱（消息邮箱）和消息队列这些被称作事件的中间环节来实现任务间的通信的，还有全局变量。</p>
<p>信号量用于：</p>
<p>1.控制共享资源的使用权（满足互斥条件）</p>
<p>2.标志某时间的发生</p>
<p>3.使2个任务的行为同步</p>
<p>消息队列：</p>
<p>概念：</p>
<p>（1）消息队列实际上就是邮箱阵列。</p>
<p>（2）任务和中断都可以将一则消息放入队列中，任务可以从消息队列中获取消息。</p>
<p>（3）先进入队列的消息先传给任务(FIFO)。</p>
<p>（4）每个消息队列有一张等待消息任务的等待列表，如果消息列中没有消息，则等待消息的任务就被挂起，直到消息到来。</p>
<h2 id="STM32-中断是怎么进入到中断服务程序的"><a href="#STM32-中断是怎么进入到中断服务程序的" class="headerlink" title="STM32 中断是怎么进入到中断服务程序的 "></a><a href="#context.12">STM32 中断是怎么进入到中断服务程序的</a><a name="section.12"> </a></h2><p>在STM32中，中断服务程序是通过中断向量表来实现的。中断向量表是一个包含中断处理程序入口地址的表格，每个中断都有一个对应的中断向量，当该中断发生时，CPU会根据中断向量表找到该中断对应的中断处理程序入口地址，并跳转到该地址执行中断处理程序。</p>
<p>中断向量表的起始地址位于STM32的Flash或者SRAM中，中断向量表的长度是固定的，每个中断向量都包含了该中断的中断处理程序入口地址。</p>
<p>当中断发生时，STM32的CPU会保存当前执行的上下文，包括程序计数器（PC）和其他寄存器等，然后根据中断向量表找到该中断对应的中断处理程序入口地址，并跳转到该地址执行中断服务程序。中断服务程序执行完成后，CPU会根据保存的上下文恢复现场，并返回到中断发生前的执行位置继续执行。</p>
<h2 id="UCOS中断处理过程"><a href="#UCOS中断处理过程" class="headerlink" title="UCOS中断处理过程 "></a><a href="#context.13">UCOS中断处理过程</a><a name="section.13"> </a></h2><p>中断是一个硬件机制，主要用来向CPU通知一个异步事件发生了，这时CPU就会将当前CPU寄存器值入栈，然后转而执行中断服务程序，在CPU执行中断服务程序的时候可能有更高优先级的任务就绪，那么当退出中断服务程序的时候，CPU就会直接执行这个高优先级的任务。</p>
<p>UCOS是支持中断嵌套的，既高优先级的中断可以打断低优先级的中断，使用OSIntNestingCtr来记录中断嵌套次数，最大支持250级的中断嵌套。进去+1，退出-1。</p>
<p>在OSIntEnter()和OSIntExit()记录</p>
<h2 id="DMA有什么用"><a href="#DMA有什么用" class="headerlink" title="DMA有什么用 "></a><a href="#context.14">DMA有什么用</a><a name="section.14"> </a></h2><p>DMA（Direct Memory Access，直接内存访问）是一种数据传输技术，它允许某些硬件子系统（例如外设控制器、IO设备等）直接在内存和外设之间传输数据，而无需CPU的干预。这样可以减轻CPU的负担，提高系统性能。</p>
<p>DMA的主要用途如下：</p>
<ol>
<li>减轻CPU负担：通过直接在内存和外设之间传输数据，DMA可以减少CPU的工作量，让CPU专注于其他任务或进入低功耗状态。</li>
<li>提高数据传输速率：DMA通常能实现较高的数据传输速率，因为它绕过了CPU并直接访问内存，从而减少了延迟和额外的开销。</li>
<li>实现实时数据传输：DMA可以实现更高的实时性，因为它可以在规定的时间内完成数据传输，而不会受到CPU其他任务的影响。</li>
<li>节省功耗：通过减少CPU参与数据传输的次数，DMA可以降低系统功耗，特别是在低功耗设备或电池供电设备中。</li>
</ol>
<p>DMA常用于以下场景：</p>
<ol>
<li>高速数据传输：例如，硬盘控制器、网络接口卡、音频设备等需要高速数据传输的应用。</li>
<li>数据采集：例如，模数转换器（ADC）、数模转换器（DAC）等需要实时采集或输出数据的设备。</li>
<li>图形处理：例如，图形处理器（GPU）在处理大量图像数据时，可以使用DMA加速数据传输。</li>
<li>嵌入式系统：在嵌入式系统中，DMA可以用于减轻CPU负担，提高系统响应速度和性能。</li>
</ol>
<h2 id="处理器与外部设备通信的两种方式"><a href="#处理器与外部设备通信的两种方式" class="headerlink" title="处理器与外部设备通信的两种方式 "></a><a href="#context.15">处理器与外部设备通信的两种方式</a><a name="section.15"> </a></h2><p>1） 并行通信：数据各个位同时传输、速度较快、占用引脚资源多</p>
<p>2） 串行通信：数据按位顺序传输、速度较慢、占用引脚资源少</p>
<h2 id="串行通信的通信方式"><a href="#串行通信的通信方式" class="headerlink" title="串行通信的通信方式 "></a><a href="#context.16">串行通信的通信方式</a><a name="section.16"> </a></h2><p>1） 同步通信：带时钟同步信号传输，SPI（全双工）、I2C（半双工）</p>
<p>2） 异步通信：不带时钟同步信号，UART（全双工）、单总线（半双工）</p>
<h2 id="串行通信分为"><a href="#串行通信分为" class="headerlink" title="串行通信分为 "></a><a href="#context.17">串行通信分为</a><a name="section.17"> </a></h2><p>1） 单工：数据传输只支持数据在一个方向上传输</p>
<p>2） 半双工：允许数据在两个方向上传输，但在某一时刻只允许数据在一个方向上传输</p>
<p>3） 全双工：允许数据同时在两个方向上传输，要求收发设备都有独立的接收、发送能力</p>
<h2 id="Modbus通讯协议"><a href="#Modbus通讯协议" class="headerlink" title="Modbus通讯协议 "></a><a href="#context.18">Modbus通讯协议</a><a name="section.18"> </a></h2><p>Modbus协议使用的是主从通讯技术，即由主设备主动查询和操作从站设备。</p>
<p>其通信遵循以下的过程：</p>
<ul>
<li>主设备向从设备发送请求</li>
<li>从设备分析并处理主设备的请求，然后向主设备发送结果</li>
<li>如果出现任何差错，从设备将返回一个异常功能码</li>
</ul>
<p>Modbus协议的报文（或帧）的基本格式是：</p>
<p>功能码和数据区在不同类型的网络都是固定不变的，表头和校验码则因网络底层的实现方式不同而有所区别。表头包含了从站的地址，功能码告诉从站要执行何种功能，数据区是具体的信息。</p>
<p>Modbus有下列三种通信方式：</p>
<p>（1）以太网：对应的通信模式是</p>
<p>（2）异步串行传输（各种介质如有线RS-232-&#x2F;422&#x2F;485&#x2F;；光纤、无线等）：对应的通信模式是Modbus RTU 或 Modbus ASCII</p>
<p>（3）高速令牌传递网络：对应的通信模式是Modbus PLUS</p>
<h2 id="485通讯的原理"><a href="#485通讯的原理" class="headerlink" title="485通讯的原理 "></a><a href="#context.19">485通讯的原理</a><a name="section.19"> </a></h2><ol>
<li>物理层：485通讯使用两根信号线，分别为A线和B线，以及一个共享的地线（GND）。A线和B线分别用于发送和接收数据，可以进行全双工通信。在通讯过程中，A线和B线的电平可以相互翻转，用来表示不同的逻辑状态，如高电平表示逻辑”1”，低电平表示逻辑”0”。</li>
<li>差分信号：485通讯采用差分信号传输，即在A线和B线之间的电压差（差分电平）来表示数据。发送端根据要发送的数据，将A线和B线上的电平进行翻转，形成一个差分信号，接收端根据电压差的大小来判断接收到的数据是逻辑”1”还是逻辑”0”。</li>
<li>驱动能力：485通讯使用驱动能力较强的驱动器芯片，能够提供足够的电流来驱动长距离的传输线路。这使得485通讯可以在远距离的环境中进行数据传输，通常可以覆盖数千米的传输距离。</li>
<li>数据帧格式：485通讯中的数据通常以数据帧的形式进行传输。一般包括起始位（Start Bit）、数据位（Data Bits）、校验位（Parity Bit）和停止位（Stop Bit）。起始位和停止位用于标识数据帧的开始和结束，数据位用于携带实际的数据，校验位用于检测数据传输的错误。</li>
<li>通讯模式：485通讯可以进行点对点通讯或多点通讯。在点对点通讯中，一个发送器和一个接收器直接进行通讯。在多点通讯中，多个设备可以通过一个共享的总线进行通讯，通过给每个设备分配不同的地址来实现数据的选择性接收。</li>
</ol>
<h2 id="RS485和RS232的区别"><a href="#RS485和RS232的区别" class="headerlink" title="RS485和RS232的区别 "></a><a href="#context.20">RS485和RS232的区别</a><a name="section.20"> </a></h2><ol>
<li>通信方式：RS232：RS232是一种点对点通信方式，即一对发送器和接收器之间进行直接通信。只有一个发送器和一个接收器参与通信。RS485：RS485是一种多点通信方式，可以在一个总线上连接多个发送器和接收器，实现多个设备之间的通信。</li>
<li>信号电平：RS232：RS232使用负逻辑电平表示逻辑“1”（-3V至-15V）和正逻辑电平表示逻辑“0”（+3V至+15V）。RS485：RS485使用差分信号传输，即A线和B线之间的电压差表示数据。电平差分范围可以根据需要调整，一般为-7V至-12V表示逻辑“1”和+7V至+12V表示逻辑“0”。</li>
<li>传输距离：RS232：RS232通常适用于短距离通信，最常见的距离为15米左右。RS485：RS485具有较强的驱动能力，能够支持长距离通信，一般可达数千米，这使得它适用于工业环境中的长距离通信需求。</li>
<li>多点通信：RS232：由于是点对点通信，RS232通常无法实现多个设备之间的直接通信。如果需要多点通信，需要采用额外的协议或设备。RS485：RS485支持多点通信，可以在同一总线上连接多个设备，通过为每个设备分配不同的地址来实现数据的选择性接收。</li>
</ol>
<h2 id="串口通信协议UART"><a href="#串口通信协议UART" class="headerlink" title="串口通信协议UART "></a><a href="#context.21">串口通信协议UART</a><a name="section.21"> </a></h2><p>UART（通用异步收&#x2F;发器）是我们单片机的串口通信接口，为全双工串行异步，UART通讯的数据包由发送设备通过自身的 TXD 接口传输到接收设备的 RXD 接口。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20230628/993465112_1687943445277/D2B5CA33BD970F64A6301FA75AE2EB22" alt="img"></p>
<p>在串口通讯的协议层中，规定了数据包的内容，它由起始位，主体数据，校验位以及停止位组成，通讯双方的数据包格式以及波特率要约定一致才能正常收发数据。</p>
<p>串口设置的一般步骤可以总结为如下几个步骤：</p>
<p>\1) 串口时钟使能，GPIO 时钟使能。</p>
<p>\2) 设置引脚复用器映射：调用 GPIO_PinAFConfig 函数。</p>
<p>\3) GPIO 初始化设置：要设置模式为复用功能。</p>
<p>\4) 串口参数初始化：设置波特率，字长，奇偶校验等参数。</p>
<p>\5) 开启中断并且初始化 NVIC，使能中断（如果需要开启中断才需要这个步骤）。</p>
<p>\6) 使能串口。</p>
<p>\7) 编写中断处理函数：函数名格式为 USARTxIRQHandler(x 对应串口号)。</p>
<h2 id="串口异步通信"><a href="#串口异步通信" class="headerlink" title="串口异步通信 "></a><a href="#context.22">串口异步通信</a><a name="section.22"> </a></h2><p>起始位、数据位、奇偶校验位、停止位、波特率设置</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20230628/993465112_1687943493927/D2B5CA33BD970F64A6301FA75AE2EB22" alt="img"></p>
<h2 id="SPI（串行外围设备接口）"><a href="#SPI（串行外围设备接口）" class="headerlink" title="SPI（串行外围设备接口） "></a><a href="#context.23">SPI（串行外围设备接口）</a><a name="section.23"> </a></h2><p>SPI（全双工同步通信）</p>
<p>以主从方式工作，这种模式通常有一个主设备和一个或多 个从设备，需要至少4根线，它们是SDI (数据输入)、SDO (数据输出)、SCLK (时钟)、CS (片选)。</p>
<p>\1. SDO&#x2F;MOSI – 主设备数据输出，从设备数据输入;</p>
<p>\2. SDI&#x2F;MISO – 主设备数据输入，从设备数据输出;</p>
<p>\3. SCLK – 时钟信号，由主设备产生;</p>
<p>4.CS&#x2F;SS – 从设备使能信号，由主设备控制。当有多个从设备的时候，因为每个从设备上都有一个片选引脚接入到主设备机中，当我们的主设备和某个从设备通信时需要将从设备对应的片选引脚电平拉低或者是拉高。</p>
<p>CS片选信号，由主设备控制。当有多个从设备的时候，因为每个从设备上都有一个片选引脚接入到主设备机中，当我们的主设备和某个从设备通信时将需要将从设备对应的片选引脚电平拉低或者是拉高（本设计是拉低则为选中）</p>
<p>多从机模式：</p>
<p>第一种多CS，每个从机都需要一条单独的SS线；第二种菊花链，在设备信号（总线信号或中断信号）以串行的方式从一个设备依次传到下一个设备，不断循环直到数据到达目标设备。</p>
<p>SPI通讯的优势：</p>
<ul>
<li>全双工串行通信；</li>
<li>高速数据传输速率。</li>
<li>简单的软件配置；</li>
<li>极其灵活的数据传输，不限于8位，它可以是任意大小的字；</li>
<li>非常简单的硬件结构。从站不需要唯一地址（与I2C不同）。从机使用主机时钟，不需要精密时钟振荡器&#x2F;晶振（与UART不同）。不需要收发器（与CAN不同）。</li>
</ul>
<p>SPI的缺点：</p>
<ul>
<li>没有硬件从机应答信号（主机可能在不知情的情况下无处发送）；</li>
<li>通常仅支持一个主设备；</li>
<li>需要更多的引脚（与I2C不同）；</li>
<li>没有定义硬件级别的错误检查协议；</li>
<li>与RS-232和CAN总线相比，只能支持非常短的距离；</li>
</ul>
<h2 id="SPI是什么？有几条线？几种模式？"><a href="#SPI是什么？有几条线？几种模式？" class="headerlink" title="SPI是什么？有几条线？几种模式？ "></a><a href="#context.24">SPI是什么？有几条线？几种模式？</a><a name="section.24"> </a></h2><p>SPI，全称为Serial Peripheral Interface，是一种串行的通信协议，用于在单片机和外设之间进行通信。SPI协议通常用于连接低速的外设，例如存储器、传感器、显示器、通信芯片等。</p>
<p>SPI通信需要至少四条线，包括：</p>
<ol>
<li>MOSI（Master Output, Slave Input）：主设备输出，从设备输入。</li>
<li>MISO（Master Input, Slave Output）：主设备输入，从设备输出。</li>
<li>SCLK（Serial Clock）：时钟线，由主设备控制。</li>
<li>SS（Slave Select）：从设备选择线，由主设备控制，可以用来选择不同的从设备进行通信。</li>
</ol>
<p>SPI协议有四种模式，每种模式具有不同的时序和时钟极性，包括：</p>
<ol>
<li>模式0：时钟极性为0，时钟相位为0，数据在时钟的下降沿被采样。</li>
<li>模式1：时钟极性为0，时钟相位为1，数据在时钟的上升沿被采样。</li>
<li>模式2：时钟极性为1，时钟相位为0，数据在时钟的上升沿被采样。</li>
<li>模式3：时钟极性为1，时钟相位为1，数据在时钟的下降沿被采样。</li>
</ol>
<p>不同的模式适用于不同的硬件设备和通信要求，需要根据具体的需求进行选择和配置。</p>
<h2 id="IIC"><a href="#IIC" class="headerlink" title="IIC "></a><a href="#context.25">IIC</a><a name="section.25"> </a></h2><p>1.它是总线，即它可以接入多个从设备</p>
<p>2.它只有两根线，即时钟线（SCL）,数据线（SDA）,但是它同一时间只有做发送或者接收线</p>
<p>3.每个连接到总线的设备，都要支持IIC，即有自己的设备地址，主机就是靠这个来区别不同的设备的</p>
<p>4.总线通过上拉电阻接到电源，即当空闲时，是高电平</p>
<p>5.多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。</p>
<p>6.具有三种传输模式：标准模式传输速率为 100kbit&#x2F;s ，快速模式为 400kbit&#x2F;s ，高速模式下可达 3.4Mbit&#x2F;s，但目前大多 I2C 设备尚不支持高速模式</p>
<p>空闲状态：I2C总线总线的SDA和SCL两条信号线同时处于高电平时，规定为总线的空闲状态。</p>
<p>开始信号：SCL 为高电平时，SDA 由高电平向低电平跳变，开始传送数据。</p>
<p>结束信号：SCL 为高电平时，SDA 由低电平向高电平跳变，结束传送数据。</p>
<p>应答信号：接收数据的 IC 在接收到 8bit 数据后，向发送数据的 IC 发出特定的低电平脉冲， 表示已收到数据。(主设备在SCL线上产生每个时钟脉冲，将在SDA线上传输一个数据位，当一个字节按数据位从高位到低位的顺序传输完后，紧接着从设备将拉低SDA线，回传给主设备一个应答位（ACK），此时才认为一个字节真正的被传输完成。)</p>
<p>CPU 向受控单元发出一个信号后，等待受控单元发出一个应答信号，CPU 接 收到应答信号后，根据实际情况作出是否继续传递信号的判断。若未收到应答信号，由判断为 受控单元出现故障。</p>
<h2 id="CAN通信介绍"><a href="#CAN通信介绍" class="headerlink" title="CAN通信介绍 "></a><a href="#context.26">CAN通信介绍</a><a name="section.26"> </a></h2><p>CAN（Controller Area Network）通信是一种串行通信协议，其主要原理如下：</p>
<ol>
<li>差分传输：CAN通信采用差分传输方式，即将数据信号和参考信号相减得到差分信号进行传输，可以有效地抵消噪声干扰，提高传输质量和可靠性。</li>
<li>帧格式：CAN通信采用基于帧的数据传输方式，每个数据帧包括了ID、数据和控制信息等多个部分。其中，ID用于区分不同的设备和数据类型，数据用于存储实际的数据信息，控制信息用于控制数据的发送和接收等操作。</li>
<li>网络拓扑：CAN通信的网络拓扑结构可以是总线型、星型或混合型，其中最常见的是总线型拓扑结构。在总线型拓扑结构中，所有的设备都连接到同一根总线上，通过差分传输的方式进行数据交换。</li>
<li>硬件控制：CAN通信的硬件控制主要包括时钟同步、数据帧的发送和接收、差分信号的转换和电平调整等。其中，时钟同步是保证通信数据同步的关键因素，CAN总线会在通信开始前进行同步校验以确保数据的正确性。</li>
<li>协议控制：CAN通信的协议控制包括数据的编码和解码、数据的传输确认和错误检测等。其中，数据的编码和解码是保证数据正确传输的关键因素，通过差分传输方式进行数据传输，CAN控制器会对数据进行检验和校验等操作以确保数据的正确性。</li>
</ol>
<h2 id="传输速度"><a href="#传输速度" class="headerlink" title="传输速度 "></a><a href="#context.27">传输速度</a><a name="section.27"> </a></h2><p>比特率（Bit&#x2F;s）和波特率，比特率是从单位看就可以知道是指每秒传输二进制的位数，而波特率是指每秒传输的码元；这里的码元我们给具体化，大家都知道串口，他的数据以帧格式传输的，即一个起始位+8位数据位+1位奇偶位+1位结束位，那么这里时候，这11位加在一起就是一个码元。</p>
<h1 id="cache的作用"><a href="#cache的作用" class="headerlink" title="cache的作用"></a>cache的作用</h1><p>缓存（Cache）是计算机系统中一种用于存储临时数据的高速存储器。它位于CPU和主存储器（如RAM）之间，用于加速对经常访问数据的读取和写入操作。缓存的主要作用是减少CPU与慢速存储器（如RAM）之间的速度差异，从而提高系统性能。</p>
<h1 id="有cache的CPU上使用DMA如何保证数据的一致性"><a href="#有cache的CPU上使用DMA如何保证数据的一致性" class="headerlink" title="有cache的CPU上使用DMA如何保证数据的一致性"></a>有cache的CPU上使用DMA如何保证数据的一致性</h1><p>缓存一致性是指确保CPU通过缓存访问的数据与内存中的实际数据保持一致。如果缓存中的数据与内存中的数据不一致，可能会导致错误的计算结果或系统行为。</p>
<p>在使用DMA时，可能会发生以下情况：</p>
<ol>
<li>DMA将数据写入内存，但CPU缓存中仍然保存有旧数据。</li>
<li>CPU将数据写入缓存，但DMA从内存中读取的是旧数据。</li>
</ol>
<p>为了确保数据一致性，可以采取以下策略：</p>
<ol>
<li>缓存刷新（Cache Flushing）：在DMA传输之前或之后，可以刷新缓存，以确保内存中的数据与缓存中的数据一致。例如，在DMA写操作之后，可以将缓存中受影响的数据行（Cache Line）标记为无效，从而在下次访问时强制从内存重新加载数据；在DMA读操作之前，可以将修改过的缓存数据写回内存，以确保DMA读取到的是最新数据。</li>
<li>缓存一致性协议（Cache Coherency Protocol）：某些处理器支持硬件缓存一致性协议，如MESI协议（Modified, Exclusive, Shared, and Invalid），用于自动维护多个缓存之间的数据一致性。这种协议可以在多核处理器或多处理器系统中使用，以便在DMA传输时自动更新相关缓存数据。</li>
<li>无缓存访问（Uncached Access）：在某些情况下，可以将DMA操作的内存区域配置为无缓存访问，即CPU直接访问内存，而不经过缓存。这样可以避免缓存一致性问题，但可能会降低数据访问性能。</li>
<li>使用缓冲区同步技术：某些操作系统或驱动程序可以提供缓冲区同步技术，如Linux内核中的函数，用于确保DMA操作和CPU访问之间的缓存一致性。</li>
</ol>
]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
</search>
