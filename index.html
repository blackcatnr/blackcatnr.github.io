<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> MustWin</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">MustWin</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['做你说过的，说你能做的', 'Do what you said, say what you can do.', ''],
        startDelay: 1000,
        typeSpeed: 300,
        loop: true,
        backSpeed: 200,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-1.markdown语法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2023/08/26/1.markdown%E8%AF%AD%E6%B3%95/" class="article-date">
  <time datetime="2023-08-26T14:54:06.558Z" itemprop="datePublished">2023-08-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<h1 id="1-markdown语法"><a href="#1-markdown语法" class="headerlink" title="1.markdown语法"></a>1.markdown语法</h1><h2 id="1-1快捷键"><a href="#1-1快捷键" class="headerlink" title="1.1快捷键"></a>1.1快捷键</h2><table>
<thead>
<tr>
<th>名称</th>
<th>语法</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>标题</td>
<td>用#表示，#一级标题，##二级标题，以此类推</td>
<td>ctrl+1&#x2F;2&#x2F;3&#x2F;4     ctrl+0快速将文本调整成普通文本     ctrl+加号&#x2F;减号对标题级别进行加减</td>
</tr>
<tr>
<td>字体加粗</td>
<td>用** **包裹起来</td>
<td>ctrl+B</td>
</tr>
<tr>
<td>斜体字</td>
<td>用* *包裹起来</td>
<td>ctrl+L</td>
</tr>
<tr>
<td>加粗斜体</td>
<td>用*** ***包裹起来</td>
<td>ctrl+B  &#x2F; ctrl+L</td>
</tr>
<tr>
<td>删除线</td>
<td>用~~ ~~ 包裹起来</td>
<td>shift+atl+5</td>
</tr>
<tr>
<td>下划线</td>
<td>用<u> <u>包裹起来</td>
<td>ctrl+U</td>
</tr>
<tr>
<td>引用</td>
<td>在文字开头添加&gt;表示引用说明</td>
<td>ctrl+Q</td>
</tr>
<tr>
<td>高亮</td>
<td>用&#x3D;&#x3D; &#x3D;&#x3D;包裹起来</td>
<td>无快捷键</td>
</tr>
<tr>
<td>插入表格</td>
<td></td>
<td>ctrl+T</td>
</tr>
<tr>
<td>在表格下方插入一行</td>
<td></td>
<td>ctrl+enter</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-2文字-文本-显示"><a href="#1-2文字-文本-显示" class="headerlink" title="1.2文字(文本)显示"></a>1.2文字(文本)显示</h2><ol>
<li>上下标：</li>
</ol>
<p>​     <code>x^2^</code></p>
<p>​    <code>H~2~O</code></p>
<p>效果：</p>
<p>​    x^2^</p>
<p>   H<del>2</del>O</p>
<p>2.文本居中</p>
<p>代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;center&gt;内容&lt;/kbd&gt;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<center>内容</kbd>

<p>3.快捷键显示<br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;kbd&gt;内容&lt;/kbd&gt;</span><br></pre></td></tr></table></figure>

<p>效果：<br><kbd>内容</kbd></p>
<p>4.加粗<br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;加粗&lt;/b&gt;</span><br></pre></td></tr></table></figure>

<p>效果：<br><b>加粗</b></p>
<p>4.倾斜<br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;i&gt;倾斜&lt;/i&gt;</span><br></pre></td></tr></table></figure>

<p>效果：<i>倾斜</i></p>
<p>5.上下标<br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开始&lt;sup&gt;123hi你好&lt;/sup&gt;</span><br><span class="line">开始&lt;sub&gt;321hi你好&lt;/sub&gt;</span><br></pre></td></tr></table></figure>

<p>效果：<br>开始<sup>123hi你好</sup><br>开始<sub>321hi你好</sub></p>
<h1 id="2-列表"><a href="#2-列表" class="headerlink" title="2.列表"></a>2.列表</h1><h2 id="2-1无序列表"><a href="#2-1无序列表" class="headerlink" title="2.1无序列表"></a>2.1无序列表</h2><p>代码：</p>
<p> <code>*/-/+ + 空格</code></p>
<p>效果：</p>
<p>1.只有同一级别：</p>
<ul>
<li><p>1</p>
</li>
<li><p>2</p>
</li>
<li><p>3</p>
<p>  2.子集类</p>
<ul>
<li>1<ul>
<li>2<ul>
<li>3</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>  快捷键：ctrl+shift+]</p>
</li>
</ul>
<h2 id="2-2有序列表"><a href="#2-2有序列表" class="headerlink" title="2.2有序列表"></a>2.2有序列表</h2><p>代码：</p>
<p><code>数字+.+空格</code></p>
<p>效果：</p>
<ol>
<li><p>第一个标题</p>
</li>
<li><p>第二个标题</p>
</li>
<li><p>第三个标题</p>
<ul>
<li>子内容1</li>
<li>子内容2</li>
</ul>
</li>
<li><p>第四个标题<br> 快捷键为ctrl+shift+[</p>
<h2 id="2-3任务列表"><a href="#2-3任务列表" class="headerlink" title="2.3任务列表"></a>2.3任务列表</h2><p> 代码：</p>
<p> <code>- [ ]吃早饭</code></p>
<p> <code>- [x]背单词</code><br> 效果：</p>
<ul>
<li><p><input disabled="" type="checkbox"> 
吃早饭</p>
</li>
<li><p><input disabled="" type="checkbox"> 
背单词</p>
</li>
</ul>
</li>
</ol>
<p>快捷键：ctrl+shift+x</p>
<h1 id="3-区块显示"><a href="#3-区块显示" class="headerlink" title="3.区块显示"></a>3.区块显示</h1><p>代码：</p>
<p><code>&gt;+回车</code></p>
<p>效果：</p>
<blockquote>
<p>这是最外层代码块</p>
<blockquote>
<p>这是内层代码块</p>
</blockquote>
<blockquote>
<blockquote>
<p>这是最内层代码块</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="代码显示"><a href="#代码显示" class="headerlink" title="代码显示"></a>代码显示</h1><h2 id="4-1行内代码"><a href="#4-1行内代码" class="headerlink" title="4.1行内代码"></a>4.1行内代码</h2><p>代码：</p>
<p><code>int a=0;</code></p>
<p>快捷键：ctrl+shift+&#96;</p>
<h2 id="4-2代码块"><a href="#4-2代码块" class="headerlink" title="4.2代码块"></a>4.2代码块</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//输出 cout</span><br><span class="line">//输入 cin</span><br></pre></td></tr></table></figure>

<p>快捷键：ctrl+shift+K</p>
<h1 id="5-链接"><a href="#5-链接" class="headerlink" title="5.链接"></a>5.链接</h1><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">www.baidu,com</span><br><span class="line">[百度](https://www.baidu.com)</span><br><span class="line">[百度])(https://www.baidu.com &quot;https://www.baidu.com&quot;)</span><br></pre></td></tr></table></figure>

<p>效果：<br><a target="_blank" rel="noopener" href="https://www.baidu.com/">百度</a><br>[百度])(<a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a> “<a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a>“)</p>
<h1 id="6-脚注"><a href="#6-脚注" class="headerlink" title="6.脚注"></a>6.脚注</h1><p>对文本进行解释说明<br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[^文本]</span><br><span class="line">[^文本]：解释说明</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p>​    c++<a href="%E8%BF%99%E6%98%AF%E4%B8%80%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">^①</a></p>
<p>c<a href="%E8%BF%99%E6%98%AF%E4%B8%80%E7%A7%8D%E7%AE%80%E5%8D%95%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">^②</a></p>
<h1 id="7-插入图片"><a href="#7-插入图片" class="headerlink" title="7.插入图片"></a>7.插入图片</h1><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![不显示的文字]（图片路径 &quot;图片标题&quot;）</span><br></pre></td></tr></table></figure>


<p>效果：<img src="/"></p>
<p>快捷键：ctrl+shift+I</p>
<h1 id="8-表格"><a href="#8-表格" class="headerlink" title="8.表格"></a>8.表格</h1><p>快捷键：</p>
<p>插入表格：ctrl+T<br>在最后一行添加一行表格：ctrl+enter<br>在一行表格里面再添加一行：shift+enter</p>
<h1 id="9-流程图"><a href="#9-流程图" class="headerlink" title="9.流程图"></a>9.流程图</h1><h1 id="10-表情符号"><a href="#10-表情符号" class="headerlink" title="10.表情符号"></a>10.表情符号</h1><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:happy: /:cry: /:man:</span><br></pre></td></tr></table></figure>

<p>效果：<br>:happy: &#x2F;:cry: &#x2F;:man:</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Free RTOS相关知识点："
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2023/08/26/Free%20RTOS%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A/" class="article-date">
  <time datetime="2023-08-26T14:54:06.558Z" itemprop="datePublished">2023-08-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <ol>
<li><p>FreeRTOS支持的三种调度方式：<br> （1）抢占式调度：主要是针对优先级不同的任务，每一个任务都有一个优先级，优先级高的任务可以抢占优先级低的任务。<br> （2）时间片调度：主要是针对优先级相同的任务，当多个任务的优先级相同时，任务调度器会在每一个时钟节拍到的时候切换任务。（时间片1ms）在FreeRTOS中，一个时间片就是SysTick中断周期。更改时间片的大小，可由更改滴答定时器中断周期去实现。</p>
<p> 补充：时间片：同等优先级的任务轮流的享有相同的CPU时间。在FreeRTOS中，一个时间片就等于一个SysTick中断周期</p>
<p> （3）协程式调度：当前执行的任务会一直执行，同时高优先级的任务不会抢占低优先级的任务。</p>
</li>
<li><p>FreeRTOS中任务共存在四种状态：<br> （1）运行态：正在执行的任务，该任务就处于运行态，注意在STM32中，同一时间仅有一个任务处于运行态。<br> （2）就绪态：如果该任务已经能够被执行，但当前还未被执行，那么该任务处于就绪态。<br> （3）阻塞态：如果一个任务因为延时或等待外部事件发生，那么这个任务就处于阻塞态。<br> （4）挂起态：类似暂停，需要调用函数vTaskSuspend()进入挂起态，调用解挂vTaskResume()才可以进入到就绪态。&#x3D;&#x3D;注意：任务处于挂起态的时候经过解挂不会直接进入到运行态，只会进入到就绪态。同样阻塞态也不会直接进行到运行态，会进入到就绪态。仅就绪态可转变为运行态，其他状态的任务想运行，必须先转为就绪态。&#x3D;&#x3D;</p>
</li>
<li><p>系统配置文件：<br> FreeRTOSConfig.h 配置文件作用：对FreeRTOS进行功能配置和裁剪，以及API函数的使能。<br> （1）“INCLUDE”： 配置FreeRTOS中可选的API<br> （2）“config” ：完成FreeRTOS的功能配置和裁剪<br> （3）其他的配置项：完成PendSV（中断）宏定义、SVC宏定义</p>
</li>
<li><p>任务的创建和删除的API函数<br>    &#x3D;&#x3D;任务的创建和删除的本质就是调用FreeRTOS的API函数&#x3D;&#x3D;<br>    两种创建方式：（1）&#x3D;&#x3D;动态方式创建&#x3D;&#x3D;（xTaskCreate）———任务的任务控制块以及任务的栈空间所需的内存，&#x3D;&#x3D;均由FreeRTOS从FreeRTOS管理的堆中分配&#x3D;&#x3D;。（2）&#x3D;&#x3D;静态方式创建&#x3D;&#x3D;（xTaskCreateStatic）———任务的任务控制块以及任务的栈空间所需的内存，&#x3D;&#x3D;需要用户分配提供。&#x3D;&#x3D;任务删除函数（xTaskToDelete）待删除任务的任务句柄，用于删除已被创键的任务，被删除的任务将从就绪态任务列表、阻塞态任务列表、挂起态任务列表和事件列表中移除。<br> 静态创建任务流程：（1）使用静态创建任务，需要将宏configSUPPORT_STATIC_ALLOCATION配置成1<br>                               （2）定义空闲任务和定时器任务的任务堆栈及TCB<br>                               （3）实现两个接口函数vApplicationGetldleTaskMemory()、vApplicationGetTimerTaskMemory()<br>                               （4） 编写任务函数<br> 删除任务流程：        （1）使用删除任务函数，需要将宏INCLUDE_vTask Delete配置为1 </p>
<p> ​                                   （2）入口参数输入需要删除的任务句柄（NULL代表删除本身）。删除任务自身，需要先添加等待删除列表，内     存释放将放在空闲任务执行 ，空闲任务会负责释放被删除任务中由系统分配的内存，但是由用户在任务删除前申请的内存，则需要由用户在任务被删除前提前释放，否则会导致内存泄漏。</p>
</li>
<li><p>任务的挂起与恢复的API函数</p>
<p> ​      三个API函数：（1）vTaskSuspend()                     ———挂起任务<br> ​                               （2）vTaskResume()                      ———恢复被挂起的任务<br> ​                               （3）vTaskResumeFromISR()       ———在中断中恢复被挂起的任务</p>
<h5 id="挂起：挂起的任务类似暂停，可恢复（解挂）；删除任务，无法恢复。被挂起的任务绝不会得到CPU的使用权，不管该任务具有什么优先级。vTaskSuspend-函数调用时需要将宏INCLUDE-vTaskSuspend-配置成1。"><a href="#挂起：挂起的任务类似暂停，可恢复（解挂）；删除任务，无法恢复。被挂起的任务绝不会得到CPU的使用权，不管该任务具有什么优先级。vTaskSuspend-函数调用时需要将宏INCLUDE-vTaskSuspend-配置成1。" class="headerlink" title="挂起：挂起的任务类似暂停，可恢复（解挂）；删除任务，无法恢复。被挂起的任务绝不会得到CPU的使用权，不管该任务具有什么优先级。vTaskSuspend() 函数调用时需要将宏INCLUDE_vTaskSuspend() 配置成1。"></a>挂起：挂起的任务类似暂停，可恢复（解挂）；删除任务，无法恢复。被挂起的任务绝不会得到CPU的使用权，不管该任务具有什么优先级。vTaskSuspend() 函数调用时需要将宏INCLUDE_vTaskSuspend() 配置成1。</h5><h5 id="恢复：恢复被挂起的任务。-任务恢复就是让挂起的任务重新进入就绪状态，恢复的任务会保留挂起前的状态信息，在恢复时根据挂起时的状态继续运行。vTaskResume-函数调用时需要将宏INCLUDE-vTaskResume-配置成1"><a href="#恢复：恢复被挂起的任务。-任务恢复就是让挂起的任务重新进入就绪状态，恢复的任务会保留挂起前的状态信息，在恢复时根据挂起时的状态继续运行。vTaskResume-函数调用时需要将宏INCLUDE-vTaskResume-配置成1" class="headerlink" title="恢复：恢复被挂起的任务。&#x3D;&#x3D;任务恢复就是让挂起的任务重新进入就绪状态，恢复的任务会保留挂起前的状态信息，在恢复时根据挂起时的状态继续运行。vTaskResume() 函数调用时需要将宏INCLUDE_vTaskResume() 配置成1&#x3D;&#x3D;"></a>恢复：恢复被挂起的任务。&#x3D;&#x3D;任务恢复就是让挂起的任务重新进入就绪状态，恢复的任务会保留挂起前的状态信息，在恢复时根据挂起时的状态继续运行。vTaskResume() 函数调用时需要将宏INCLUDE_vTaskResume() 配置成1&#x3D;&#x3D;</h5><h6 id="FromISR：-带FromISR后缀是在中断函数中专用的API-。无论调用过多少次的任务挂起vTaskSuspend-，只需要调用一次vTaskResumeFromISR-即可解挂。-使用该函数时，需要在FreeRTOSconfig-h中把INCLUDE-vTaskSuspend-和INCLUDE-vTaskResumeFromISR-都定义为1。-vTaskResumeFromISR-函数不能用于任务和中断的同步（因为中断随时可能出现）。"><a href="#FromISR：-带FromISR后缀是在中断函数中专用的API-。无论调用过多少次的任务挂起vTaskSuspend-，只需要调用一次vTaskResumeFromISR-即可解挂。-使用该函数时，需要在FreeRTOSconfig-h中把INCLUDE-vTaskSuspend-和INCLUDE-vTaskResumeFromISR-都定义为1。-vTaskResumeFromISR-函数不能用于任务和中断的同步（因为中断随时可能出现）。" class="headerlink" title="FromISR：&#x3D;&#x3D;带FromISR后缀是在中断函数中专用的API&#x3D;&#x3D;。无论调用过多少次的任务挂起vTaskSuspend() ，只需要调用一次vTaskResumeFromISR()  即可解挂。&#x3D;&#x3D;使用该函数时，需要在FreeRTOSconfig.h中把INCLUDE_vTaskSuspend()和INCLUDE_vTaskResumeFromISR()  都定义为1。&#x3D;&#x3D;vTaskResumeFromISR()函数不能用于任务和中断的同步（因为中断随时可能出现）。"></a>FromISR：&#x3D;&#x3D;带FromISR后缀是在中断函数中专用的API&#x3D;&#x3D;。无论调用过多少次的任务挂起vTaskSuspend() ，只需要调用一次vTaskResumeFromISR()  即可解挂。&#x3D;&#x3D;使用该函数时，需要在FreeRTOSconfig.h中把INCLUDE_vTaskSuspend()和INCLUDE_vTaskResumeFromISR()  都定义为1。&#x3D;&#x3D;vTaskResumeFromISR()函数不能用于任务和中断的同步（因为中断随时可能出现）。</h6><p> ​    vTaskSuspend(TaskHandle_t  vTaskSuspend) 形参为 vTaskSuspend，待挂起任务的任务句柄。注意：当传入的参数为NULL，则代表挂起任务自身（当前运行的任务）。<br> ​    vTaskResume(TaskHandle_t  vTaskResume) 形参为vTaskResume，恢复指定任务的任务句柄。注意：任务无论被挂起多少次，只需要调用vTaskResume()恢复一次，就可以继续运行。且被恢复的任务进入到就绪态。<br>   &#x3D;&#x3D;BaseType_t&#x3D;&#x3D; xTaskResumeFromISR(TaskHandle_t  xTaskResume)  被标记的为函数的返回值类型，形参为xTaskResume，待恢复的任务句柄。返回值类型有两种：①pdTRUE ———任务恢复后需要进行任务切换 （&#x3D;&#x3D;进行任务切换的情况可能为进行抢占式调度，当前恢复的任务的优先级大于正在执行的任务的优先级&#x3D;&#x3D;）②pdFALSE———任务恢复后不需要进行任务切换。&#x3D;&#x3D;注意：中断服务程序中要调用FreeRTOS的API函数则中断优先级不能超过FreeRTOS所管理的最高优先级。&#x3D;&#x3D;</p>
<p> ​               &#x3D;&#x3D;小知识点补充：任务优先级是数值越大优先级越高，中断优先级是数值越小优先级越高。&#x3D;&#x3D;</p>
</li>
<li><p>中断管理</p>
</li>
</ol>
<p>​           中断:让CPU打断正常运行的程序，转而去处理紧急的事件。中断属于异步异常。</p>
<p>​           异常：导致处理器脱离正常运行转向执行特殊代码的任何事件，如果不及时处理，轻则系统出错，重则导致系统瘫痪。异常分类： 同步异常和异步异常。有内部事件引起的异常叫做同步异常。异步异常主要指由外部异常源产生的异常。</p>
<p>​          中断执行机制：1.中断请求：外设产生中断请求（GPIO外部中断、定时器中断等）2.响应中断：CPU停止执行当前程序，转而去执行中断处理程序（ISR）3.退出中断：执行完毕，返回被打断的程序处，继续执行。</p>
<p>​         中断优先级分组设置：1.低于configMAX_SYSCALL_INTERRUPT_PRIORITY优先级的中断里才允许调用FreeRTOS的API函数<br>​                                                2.建议将所有优先级位指定为抢占优先级位，方便FreeRTOS管理。（调用函数HAL_NVIC_SePriorityGrouping(NVIC_PRIORITYGROUP_4）</p>
<p>​     三个系统中断优先级配置寄存器，分别为SHPR1、SHPR2、SHPR3，通过SHPR3将PendSV 和SysTick的中断优先级设置成最低优先级，保证系统任务切换不会阻塞系统其他中断的响应。</p>
<p>​    三个中断屏蔽寄存器，分别为PRIMASK、FAULTMASK、BASEPRI。FreeRTOS所使用的中断管理就是利用的BASEPRI寄存器，BASEPRI：屏蔽优先级低于某一个阈值的中断。</p>
<p>补充知识点：PendSV<strong>定义：</strong>可悬起异常，如果我们把它配置为最低<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BC%98%E5%85%88%E7%BA%A7&spm=1001.2101.3001.7020">优先级</a>，那么如果同时有多个异常被触发，他会再其他异常执行完毕后再执行，而且任何异常都可以打断它。systick<strong>定义</strong>（就是一个基于M3、M4内核的一个简单的24bit,倒计时,自动重装载定时器，倒计时结束会产生一个中断。常用于做延时，在实时系统中做心跳时钟，用于任务的切换。</p>
<p>​                                     1、systick定时器，就是系统滴答定时器</p>
<p>​                                    2、24位自动重装载倒计时定时器</p>
<p>​                                    3、当倒计时到0时，将从RELOAD寄存器中自动重装载初值</p>
<p>​                                   4、只要不清除SysTick控制及状态寄存器的使能位，就永不停息，在睡眠模式下也能工作</p>
<p>​                                    5、systick倒计时结束，会产生一个中断，且中断优先级可以设置</p>
<ol start="7">
<li>临界段代码保护</li>
</ol>
<p> &#x3D;&#x3D;临界段代码也叫做临界区，是指那些必须完整运行，不能被打断的代码段。&#x3D;&#x3D;适用场合：①外设：需要严格按照时序初始化的外设；②系统：系统自身；③用户自身</p>
<p>FreeRTOS在进入临界段代码的时候需要关闭中断，当处理完临界段代码以后再打开中断。</p>
<p>临界段代码保护函数：<br>                              ①taskENTER_CRITICAL() ———任务级进入临界段（关中断）<br>                              ②taskEXIT_CRITICAL() ———任务级退出临界段（开中断）<br>                              ③taskENTER_CRITICAL_FROM_ISR() ———中断级进入临界段（关中断）<br>                              ④taskEXIT_CRITICAL_FROM_ISR() ———中断级退出临界段（开中断）</p>
<ol start="8">
<li>任务调度器的挂起和恢复</li>
</ol>
<p>​       挂起任务调度器，调用此函数不需要关闭中断。</p>
<p>函数：①vTaskSuspendAll()  挂起任务调度器<br>           ②xTaskResumeAII()   恢复任务调度器</p>
<p>注意   1.与临界区不一样的是，挂起任务调度器，不需要关闭中断<br>           2.它仅仅是防止任务之间的资源争夺，中断照样可以直接响应；<br>           3.挂起调度器的方式，适用于临界区位于任务于任务之间，既不用去延时中断，又可以做到临界区的安全。</p>
<ol start="9">
<li>FreeRTOS的列表和列表项</li>
</ol>
<p>列表是FreeRTOS中的一个数据结构，概念上和链表类似，列表用来跟踪FreeRTOS中的任务。列表项就是放在列表中的项目。</p>
<p>列表根节点定义：<br><code>typedef struct xLIST</code></p>
<p><code>&#123;UBaseType_t uxNumberOfItems;</code>&#x2F;&#x2F;用于定于链表的节点计数器。用于表示该链表下有多少个节点，根节点除外。<br>   <code>ListItem_t * pxIndex;</code>&#x2F;&#x2F;链表节点索引指针，用于遍历节点。<br><code>MinListItem_t xListEnd;</code>&#x2F;&#x2F;链表的最后一个节点。<br><code>&#125;;</code></p>
<p>列表项：</p>
<p>​      <code>struct xLIST_ITEM</code><br><code>&#123;</code><br>​         <code>listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE        用于检测列表项的数据完整（未用到可以不看）</code></p>
<p>​        <code>configLIST_VOLATILE_TickType_t xltemValue          列表项的值</code><br>​        <code>struct xLIST_ITEM\*configLIST_VOLATILE  pxNext     下一个列表项</code><br>​        <code>struct xLIST_ITEM\*configLIST_VOLATILE  pxPrevious    上一个列表项</code><br>​        <code>void* pvOwner                                                                 列表项的拥有者</code><br>​        <code>struct xLIST_ITEM*configLIST_VOLATILE  pxContainer          列表项所在列表</code><br>​        <code>listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE                 用于检测列表项的数据完整性（未用到可以不看）</code></p>
<p><code>&#125;;</code></p>
<p>（1）成员变量xltemValue为列表项的值<br>（2）成员变量pxNext 、 pxPrevious表示列表中列表项下一个列表项和上一个列表项<br>（3）成员变量pvOwner用于指向包含列表项的对象<br>（4）成员变量pxContainer用于指向列表项所在的列表</p>
<p>迷你列表项：也是列表项，但迷你列表项仅用于标记列表的末尾和挂载在其他插入列表中的列表项。</p>
<pre><code>  struct xMINI_LIST_ITEM
</code></pre>
<p><code>&#123;</code><br>        <code>listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE         用于检测列表项的数据完整（未用到可以不看)</code><br>        <code>configLIST_VOLATILE_TickType_t xltemValue            列表项的值 </code></p>
<p><code>           struct xLIST_ITEM\*configLIST_VOLATILE  pxNext     下一个列表项</code><br>          <code>struct xLIST_ITEM\*configLIST_VOLATILE  pxPrevious    上一个列表项</code></p>
<p><code>&#125;</code>;</p>
<p>（1）成员变量xltemValue为列表项的值，这个值多用于按升序对列表中的列表项进行排序<br>（2）成员变量pxNext 、 pxPrevious表示列表中列表项下一个列表项和上一个列表项<br>（3）迷你列表项仅用于标记列表的末尾和挂载在其他插入列表中的列表项，因此不需要成员变量pvOwner和pxContainer，以节省内存开销。</p>
<ol start="10">
<li>任务切换</li>
</ol>
<p>任务切换的实质：就是CPU寄存器的切换。</p>
<p> 假设由任务A切换到任务B，主要分成两步：①需要暂停当前任务A的执行，并将此时任务A的寄存器保存到任务堆栈中，这个过程叫做任保存现场（压栈）。②将任务B的各个寄存器的值（被存于任务堆栈中）恢复到CPU寄存器中，这个过程叫做恢复现场（出栈）。对任务A的保存现场，任务B的恢复现场也叫做上下文切换。<br>注意：任务切换的过程在PendSV()中断服务函数里边完成。<br>             PendSV中断是如何触发的？（1）滴答定时器中断调用（2）执行FreeRTOS提供的相关API函数：portYIELD()。本质：通过向中断控制和状态寄存器ICSR（地址：0xE000_ED04）的bit写1挂起PendSV来启动PendSV中断。</p>
<ol start="11">
<li>时间片调度</li>
</ol>
<p>使用时间片调度需要把宏configUSE_TIME_SLICING和configUSE_PREEMPTION置1。</p>
<p>时间统计API函数——void vTaskGetRunTimeStats(char* pcWriteBuffer)   此函数用于统计任务的运行时间，使用此函数需要将宏configGENERATE_RUN_TIME_STAT、configUSE_STATS_FORMATTING_FUNCTIONS置1。pcWriteBuffer接受任务运行时间信息的缓存指针。<br>时间统计API函数使用流程<br>（1）将宏configGENERATE_RUN_TIME_STAT置1.<br>（2）将宏configUSE_STATS_FORMATTING_FUNCTIONS置1.<br>（3）将宏configGENERATE_RUN_TIME_STAT置1后 ，还需要实现两个宏定义：①portCONFIGURE_TIME_FOR_RUNTIME_STATE():用于初始化用于配置任务运行时间统计的时基定时器；②portGET_RUN_TIME_COUNTER_VALUE():用于获取该功能时基硬件定时器计数的计数值。<br>延时函数：<br>        相对延时（vTaskDelay()）：指每次延时都是从执行函数vTaskDelay()开始，直到延时指定时间结束<br>        绝对延时（vTaskDelayUntil()）:指将整个任务的运行周期看成一个整体，适用于需要按照一定频率运行的任务。                      </p>
<ol start="12">
<li>队列</li>
</ol>
<p>队列又称为消息队列，队列可以在任务与任务之间、中断与任务之间传递信息，实现了任务接收来自于其他任务或中断的不固定长的数据。 任务能够从队列中读取消息，当队列中的消息为空时，读取消息的任务将被阻塞。</p>
<p>FreeRTOS中的队列的特点：<br> ①数据出入队方式：队列采用”先进先出“（FIFO）的数据存储缓冲机制，即先入队的数据会先从队列出来。<br> ②数据传递方式： FreeRTOS中队列采用实际值传递，即将数据拷贝到队列中进行传递，FreeRTOS采用拷贝数据传递，也可以传递指针，所以在传达较大的数据的时候采用指针传递。<br> ③多人任务访问：队列不属于任何某个认任务，任何任务和中断都可以向队列发送&#x2F;读取消息。<br> ④出队、入队阻塞：当任务向一个队列发送消息时，可以指定一个阻塞时间。<br>      入队阻塞：队列已满，此时写不进去数据。①将该任务的状态列表项挂载在pxDelayedTasksList()(阻塞任务列表);②将任务的事件列表项挂载在xTaskWaitingToSend()(等待发送列表)。<br>      出队阻塞：队列为空 ，此时读取不了数据。①将该任务的状态列表项挂载在pxDelayedTasksList()(阻塞任务列表)；②将任务的事件列表项挂载在xTasksWaitingToReceive(); 	</p>
<ol start="13">
<li>信号量</li>
</ol>
<p>信号量是一种解决同步问题的机制，可以实现对共享资源的有序访问。是一种实现任务间通信的机制，可以实现任务之间同步或临界资源的互斥访问。&#x3D;&#x3D;信号量是一个非负的整数，&#x3D;&#x3D;所有获取它的任务都会将整数减一，当该整数值为0时，所有试图获取它的任务都将处于阻塞态。通常一个信号量的计数值用对应有效的资源数，表示剩下的可被占用的互斥资源数。</p>
<p>&#x3D;&#x3D;当计数值大于0时，代表有信号量资源；当释放信号量，信号量计数值加1；当任务获取信号量时，信号量计数值减1。&#x3D;&#x3D;</p>
<p>队列和信号量的区别：</p>
<table>
<thead>
<tr>
<th align="center">队列</th>
<th align="center">信号量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">可以容纳多个数据；创建队列有两部分内存：队列结构体（消息队列的控制块）、队列项存储空间（队头+队尾）</td>
<td align="center">仅存放计数值，无法存放其他数据；创建信号量，只需分配信号量的结构体</td>
</tr>
<tr>
<td align="center">写入队列：当队列满时，可阻塞；</td>
<td align="center">释放信号量：不可阻塞，计数值进行++；当计数值超过最大值时，返回失败</td>
</tr>
<tr>
<td align="center">读取队列：当队列没有数据时，可阻塞；</td>
<td align="center">获取信号量：计数值- -；当没有资源时，可以阻塞；</td>
</tr>
</tbody></table>
<p>二值信号量：本质上就是一个队列长度为1的队列，该队列就只有空和满两种情况。通常用于互斥访问或任务同步，与互斥信号量比较类似，但是二值信号量有可能会导致优先级翻转问题，二值信号量更适合用于任务同步，互斥信号量更适合用于临界资源的访问。<br>&#x3D;&#x3D;二值信号量和互斥信号量区别：互斥量有优先级继承机制，二值信号量没有这个机制。&#x3D;&#x3D;<br>在FreeRTOS中，信号量用于同步，如任务与任务的同步、中断与任务的同步，可以大大提高效率。</p>
<p>计数型信号量：本质上相当于队列长度大于1的队列，因此计数型信号量能够容纳多个资源，这个是在计数型信号量创建时确定的。<br>计数型信号量适用场合：①事件计数：当每次事件发生后，在事件处理函数中释放计数型信号量（计数值加1），其他任务会获计数型信号量（计数值减1），这个场合一般在创建时将初始计数值设置为0；②资源管理：信号量表示有效的资源数目。任务必须先获取信号量（信号量数值减1）才能获取资源控制权。当计数值减到0时，表示没有资源。当任务用完资源后，必须释放信号量（计数值加1）。信号量创建时计数值应等于最大资源数目。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-嵌入式八股文1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2023/08/26/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%85%AB%E8%82%A1%E6%96%871/" class="article-date">
  <time datetime="2023-08-26T14:54:06.558Z" itemprop="datePublished">2023-08-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="芯片选型考虑哪些因素？"><a href="#芯片选型考虑哪些因素？" class="headerlink" title="芯片选型考虑哪些因素？"></a>芯片选型考虑哪些因素？</h2><ol>
<li>性能：确保芯片具有足够的处理能力来满足项目需求。</li>
<li>内存：选择具有足够RAM和ROM（或Flash）容量的芯片。</li>
<li>能耗：根据项目要求，权衡功耗和性能。</li>
<li>外设和接口：选择支持所需通信协议和设备连接的芯片。</li>
<li>封装和尺寸：考虑空间限制和生产要求，选择合适的封装类型。</li>
<li>开发工具和支持：选用具有良好文档和支持的芯片，降低开发难度。</li>
<li>供应和成本：确保稳定供应并选择性价比合适的芯片。</li>
<li>软件和生态系统：选择具有成熟软件支持和丰富生态系统的芯片。</li>
<li>安全性：根据项目要求，选择具有相应安全功能的芯片。</li>
<li>可扩展性：选择具有一定可扩展性和升级能力的芯片，以适应项目需求变化。</li>
</ol>
<h2 id="STM32F4和F1的区别，为什么选用F4？"><a href="#STM32F4和F1的区别，为什么选用F4？" class="headerlink" title="STM32F4和F1的区别，为什么选用F4？"></a>STM32F4和F1的区别，为什么选用F4？</h2><p>内核不同：F1是Cortex-M3内核，F4是Cortex-M4内核；</p>
<p>主频不同：F1主频72MHz，F4主频168MHz；</p>
<p>浮点运算：F1无浮点运算单位没有硬件FPU处理浮点数运算，F4有；</p>
<p>（没有浮点加速硬件FPU只影响浮点计算的速度，并不是不能计算浮点数，因此只能通过内核的软件进行计算。先要把这个浮点数运算转换成定点数存储，再把这个定点数转换成指数的方式进行运算，不仅中间要进行数据转换，并且要进行多次移位，而整数型就不需要这么复杂的操作，直接运算就可以，所以F1浮点数运算不仅运算量大并且会加大MCU的负载，要慢很多）</p>
<p>功能性能：F4外设比F1丰富且功能更强大，比如GPIO翻转速率、上下拉电阻配置、ADC精度等；</p>
<p>内存大小：F1内部SRAM最大64K，F4有192K(112+64+16)。</p>
<p>F4的RAM和ROM：ram192K，rom大小2048K</p>
<p>考虑到需要浮点运算和使用RTOS系统，最后选择F4；</p>
<h2 id="STM32启动过程："><a href="#STM32启动过程：" class="headerlink" title="STM32启动过程："></a>STM32启动过程：</h2><ol>
<li>复位向量表（Reset Vector Table）：在STM32微控制器中，复位向量表是一个存储器区域，其中包含了处理器在复位时跳转执行的第一条指令的地址。通常，复位向量表位于存储器的起始地址，由芯片制造商预先定义。复位向量表的内容包括复位中断处理函数、中断向量表和其他初始化函数。</li>
<li>处理器复位：当STM32芯片上电或者外部复位信号触发时，处理器的复位引脚将会被拉低，导致处理器执行复位操作。在复位期间，处理器会将各个寄存器的值初始化为默认值，并开始执行复位向量表中的第一条指令。</li>
<li>系统初始化：复位向量表中的第一条指令通常是一条跳转指令，将控制权转移到系统初始化函数的地址上。系统初始化函数主要用于设置处理器和系统的一些基本配置，例如时钟源和时钟频率的配置，初始化堆栈指针、全局变量等。</li>
<li>C库初始化：在系统初始化完成后，通常会调用C库的初始化函数。C库的初始化函数主要是对C语言运行环境的初始化，包括清零BSS段（未初始化的全局变量）、复制数据段（初始化的全局变量）等。</li>
<li>主函数入口：C库初始化完成后，处理器将跳转到主函数的入口地址开始执行用户程序。主函数是程序的入口点，其中包含应用程序的具体逻辑。</li>
</ol>
<p>需要注意的是，上述步骤是一般情况下的启动流程，具体的启动过程可能会因不同的芯片型号、启动模式和编译器设置而有所差异。此外，还可以通过修改复位向量表的内容来实现特定的启动操作，例如自定义复位中断处理函数或添加其他初始化函数。</p>
<h2 id="stm32的定时器"><a href="#stm32的定时器" class="headerlink" title="stm32的定时器"></a>stm32的定时器</h2><p>提问定时器相关的，具体根据你个人开发使用情况解答。</p>
<ol>
<li>定时器时钟使能：首先，需要使能所需的定时器时钟。这可以通过RCC（Reset and Clock Control）寄存器来配置。例如，如果要使用TIM2定时器，需要使能TIM2的时钟。</li>
<li>定时器配置：配置定时器的基本参数，例如计数器的工作模式、时钟分频系数、计数器的自动重载值等。这些配置可以通过定时器的相关寄存器进行设置。</li>
<li>定时器中断设置（可选）：如果需要使用定时器中断，可以配置中断源和中断优先级，并使能定时器中断。</li>
<li>启动定时器：配置完成后，启动定时器开始计数。定时器可以通过软件触发或外部触发来启动计数。</li>
<li>定时器中断处理（可选）：如果配置了定时器中断，当计数器达到设定的值时，会触发中断。在中断服务程序中可以执行相应的操作，例如更新计数器的值、处理中断标志等。</li>
</ol>
<h2 id="stm32的AD采样"><a href="#stm32的AD采样" class="headerlink" title="stm32的AD采样"></a>stm32的AD采样</h2><p>提问AD采样相关的，具体根据你个人开发使用情况解答。</p>
<ol>
<li>ADC配置：首先，需要配置ADC模块的相关寄存器，包括时钟使能、采样时间、采样通道等。这些配置可以通过寄存器操作或者使用STM32提供的库函数进行设置。</li>
<li>GPIO配置：为了使用ADC，需要将相应的GPIO引脚配置为模拟输入模式，并使能相应的ADC通道。这可以通过配置GPIO寄存器来完成。</li>
<li>触发方式设置：可以选择触发ADC转换的方式，例如软件触发或外部触发。如果选择外部触发，还需要配置相关的触发源和极性。</li>
<li>ADC转换：在进行ADC转换之前，可以设置ADC分辨率、对齐方式、连续转换模式等。然后，可以通过启动转换命令或触发源来开始ADC转换。</li>
<li>中断或轮询获取结果：可以选择使用中断或轮询的方式获取ADC转换结果。如果使用中断方式，可以在转换完成后触发中断，并在中断服务程序中读取转换结果。如果使用轮询方式，则需要在转换完成后主动查询并读取转换结果。</li>
<li>结果处理：获取到ADC转换结果后，可以根据需要进行相应的处理，例如数据转换、单位换算等。</li>
</ol>
<h2 id="Linux嵌入式和单片机嵌入式区别："><a href="#Linux嵌入式和单片机嵌入式区别：" class="headerlink" title="Linux嵌入式和单片机嵌入式区别："></a>Linux嵌入式和单片机嵌入式区别：</h2><p>复杂性：Linux嵌入式系统是基于Linux内核构建的，具有完整的操作系统功能，包括多任务处理、文件系统、网络协议等。相比之下，单片机嵌入式系统通常使用裸机编程或者实时操作系统（RTOS），具有更简单的系统结构和功能。</p>
<p>处理能力：Linux嵌入式系统通常在较强大的处理器上运行，例如ARM、x86等，具备较高的处理能力和存储容量。而单片机嵌入式系统使用单片机芯片，其处理能力和存储容量较低。</p>
<p>开发环境：Linux嵌入式系统使用标准的开发工具链和开发环境，可以使用高级编程语言（如C&#x2F;C++）进行开发，并且具备广泛的软件支持和开发社区。单片机嵌入式系统的开发通常需要使用特定的单片机编程工具和汇编语言，开发资源相对较少。</p>
<p>系统定制性：Linux嵌入式系统具有很高的可定制性，可以根据应用需求选择所需的软件组件和功能，并且支持模块化的软件开发和更新。单片机嵌入式系统的定制性相对较低，往往需要在设计阶段确定所需功能和硬件配置。</p>
<p>成本和功耗：Linux嵌入式系统由于使用较高性能的处理器和较大容量的存储器，相对而言成本较高，并且功耗较高。单片机嵌入式系统由于采用低成本、低功耗的单片机芯片，成本较低且功耗较低。</p>
<p>总的来说，Linux嵌入式系统适用于需要复杂功能、较高性能和较大存储容量的应用，如智能手机、平板电脑、网络设备等。而单片机嵌入式系统适用于资源有限、功耗要求低、对实时性要求较高的应用，如传感器、家电、汽车电子等。</p>
<h2 id="FreeRTOS、μC-OS的区别"><a href="#FreeRTOS、μC-OS的区别" class="headerlink" title="FreeRTOS、μC&#x2F;OS的区别"></a>FreeRTOS、μC&#x2F;OS的区别</h2><p>开源性质：FreeRTOS是一个开源的RTOS，可以免费获取并在商业和非商业项目中使用。它具有广泛的用户社区和支持。而μC&#x2F;OS是一种商业RTOS，需要购买许可证才能使用。</p>
<p>架构和内核：FreeRTOS采用基于优先级的抢占式内核架构，支持多任务处理、时间片轮转调度和中断服务机制。它提供了一套轻量级的内核函数和任务管理机制。μC&#x2F;OS也是基于优先级的抢占式内核，但它提供了更多的功能，如事件标志、信号量、消息邮箱等，以满足更复杂的应用需求。</p>
<p>资源占用：FreeRTOS的内核非常小巧，具有低的存储器占用和快速的上下文切换速度，适用于资源有限的嵌入式系统。μC&#x2F;OS相对而言具有更大的内核代码大小和更高的存储器占用，但它提供了更丰富的功能和可选组件。</p>
<p>硬件平台支持：FreeRTOS在多种处理器架构上都有支持，包括ARM、MIPS、x86等，因此它适用于广泛的硬件平台。μC&#x2F;OS也支持多种处理器架构，但支持的硬件平台较少，且主要集中在微控制器和嵌入式系统上。</p>
<p>社区支持和生态系统：由于FreeRTOS的开源性质，它具有庞大的用户社区和广泛的生态系统，提供了丰富的示例代码、开发工具和支持资源。μC&#x2F;OS作为商业RTOS，其用户社区和生态系统相对较小，但有专门的技术支持和服务。</p>
<h2 id="在RTOS中，二值信号量和互斥量的区别？"><a href="#在RTOS中，二值信号量和互斥量的区别？" class="headerlink" title="在RTOS中，二值信号量和互斥量的区别？"></a>在RTOS中，二值信号量和互斥量的区别？</h2><p>二值信号量是一种计数器，只有两种状态：0和1。当一个任务试图获取一个已经被获取的二值信号量时，该任务会被挂起，直到该信号量被释放为止。二值信号量通常用于同步任务的开始或者结束，或者是保护共享资源的读写等。由于二值信号量不具有优先级继承功能，当高优先级任务等待低优先级任务释放二值信号量时，低优先级任务可能会优先执行，导致任务调度出现问题。</p>
<p>互斥量也是一种计数器，但它具有更多的状态。当一个任务获取一个已经被获取的互斥量时，该任务会被挂起，并且该互斥量的计数器会减一。只有当计数器归零时，该互斥量才会被释放。互斥量通常用于保护共享资源的读写等，它具有优先级继承功能，可以避免高优先级任务因为等待低优先级任务释放互斥量而被阻塞的问题。</p>
<h2 id="在RTOS中，任务通知的运行机制是怎么样的？"><a href="#在RTOS中，任务通知的运行机制是怎么样的？" class="headerlink" title="在RTOS中，任务通知的运行机制是怎么样的？"></a>在RTOS中，任务通知的运行机制是怎么样的？</h2><ol>
<li>发送任务向接收任务发送通知，通知包括通知值和接收任务的句柄。</li>
<li>接收任务准备好接收通知，并在等待通知列表中等待通知的到来。</li>
<li>发送任务调用发送通知的API函数，RTOS将通知保存到接收任务的等待通知列表中。</li>
<li>如果接收任务已经准备好接收通知，那么RTOS会将该任务从等待通知列表中移除，并唤醒该任务继续执行。</li>
<li>如果接收任务没有准备好接收通知，那么该任务会继续等待，直到接收任务准备好接收通知。</li>
</ol>
<h2 id="UCOS任务调度"><a href="#UCOS任务调度" class="headerlink" title="UCOS任务调度"></a>UCOS任务调度</h2><p>一个任务，也称作一个线程。</p>
<p>UCOS有一个任务调度机制，根据任务的优先级进行调度。</p>
<p>一个是硬件中断， 那么系统会将当前任务有关变量入栈，然后执行中断服务程序，执行完成后出栈返回.</p>
<p>另一个是任务之间的切换，使用的方法就是任务调度，每一个任务有自己的栈，顺度也是一样的入栈，然后执行另一个程序，然后出线返回。</p>
<p>并非是每一任务按优先级顺序轮流执行的，而是高优先级的任务独占运行，除非其主动放弃执行，否则低优先级任务不能抢占，同时高优先级可以把放出去给低优先级任务使用的CPU占用权抢回来。所以UCOS的任务间要注意插入等待延时，以便UCOS切出去让低优先级任务执行。</p>
<h2 id="UCOS中任务间的通信"><a href="#UCOS中任务间的通信" class="headerlink" title="UCOS中任务间的通信"></a>UCOS中任务间的通信</h2><p>在UCOS中，是使用信号量、邮箱（消息邮箱）和消息队列这些被称作事件的中间环节来实现任务间的通信的，还有全局变量。</p>
<p>信号量用于：</p>
<p>1.控制共享资源的使用权（满足互斥条件）</p>
<p>2.标志某时间的发生</p>
<p>3.使2个任务的行为同步</p>
<p>消息队列：</p>
<p>概念：</p>
<p>（1）消息队列实际上就是邮箱阵列。</p>
<p>（2）任务和中断都可以将一则消息放入队列中，任务可以从消息队列中获取消息。</p>
<p>（3）先进入队列的消息先传给任务(FIFO)。</p>
<p>（4）每个消息队列有一张等待消息任务的等待列表，如果消息列中没有消息，则等待消息的任务就被挂起，直到消息到来。</p>
<h2 id="STM32-中断是怎么进入到中断服务程序的"><a href="#STM32-中断是怎么进入到中断服务程序的" class="headerlink" title="STM32 中断是怎么进入到中断服务程序的"></a>STM32 中断是怎么进入到中断服务程序的</h2><p>在STM32中，中断服务程序是通过中断向量表来实现的。中断向量表是一个包含中断处理程序入口地址的表格，每个中断都有一个对应的中断向量，当该中断发生时，CPU会根据中断向量表找到该中断对应的中断处理程序入口地址，并跳转到该地址执行中断处理程序。</p>
<p>中断向量表的起始地址位于STM32的Flash或者SRAM中，中断向量表的长度是固定的，每个中断向量都包含了该中断的中断处理程序入口地址。</p>
<p>当中断发生时，STM32的CPU会保存当前执行的上下文，包括程序计数器（PC）和其他寄存器等，然后根据中断向量表找到该中断对应的中断处理程序入口地址，并跳转到该地址执行中断服务程序。中断服务程序执行完成后，CPU会根据保存的上下文恢复现场，并返回到中断发生前的执行位置继续执行。</p>
<h2 id="UCOS中断处理过程"><a href="#UCOS中断处理过程" class="headerlink" title="UCOS中断处理过程"></a>UCOS中断处理过程</h2><p>中断是一个硬件机制，主要用来向CPU通知一个异步事件发生了，这时CPU就会将当前CPU寄存器值入栈，然后转而执行中断服务程序，在CPU执行中断服务程序的时候可能有更高优先级的任务就绪，那么当退出中断服务程序的时候，CPU就会直接执行这个高优先级的任务。</p>
<p>UCOS是支持中断嵌套的，既高优先级的中断可以打断低优先级的中断，使用OSIntNestingCtr来记录中断嵌套次数，最大支持250级的中断嵌套。进去+1，退出-1。</p>
<p>在OSIntEnter()和OSIntExit()记录</p>
<h2 id="DMA有什么用"><a href="#DMA有什么用" class="headerlink" title="DMA有什么用"></a>DMA有什么用</h2><p>DMA（Direct Memory Access，直接内存访问）是一种数据传输技术，它允许某些硬件子系统（例如外设控制器、IO设备等）直接在内存和外设之间传输数据，而无需CPU的干预。这样可以减轻CPU的负担，提高系统性能。</p>
<p>DMA的主要用途如下：</p>
<ol>
<li>减轻CPU负担：通过直接在内存和外设之间传输数据，DMA可以减少CPU的工作量，让CPU专注于其他任务或进入低功耗状态。</li>
<li>提高数据传输速率：DMA通常能实现较高的数据传输速率，因为它绕过了CPU并直接访问内存，从而减少了延迟和额外的开销。</li>
<li>实现实时数据传输：DMA可以实现更高的实时性，因为它可以在规定的时间内完成数据传输，而不会受到CPU其他任务的影响。</li>
<li>节省功耗：通过减少CPU参与数据传输的次数，DMA可以降低系统功耗，特别是在低功耗设备或电池供电设备中。</li>
</ol>
<p>DMA常用于以下场景：</p>
<ol>
<li>高速数据传输：例如，硬盘控制器、网络接口卡、音频设备等需要高速数据传输的应用。</li>
<li>数据采集：例如，模数转换器（ADC）、数模转换器（DAC）等需要实时采集或输出数据的设备。</li>
<li>图形处理：例如，图形处理器（GPU）在处理大量图像数据时，可以使用DMA加速数据传输。</li>
<li>嵌入式系统：在嵌入式系统中，DMA可以用于减轻CPU负担，提高系统响应速度和性能。</li>
</ol>
<h2 id="处理器与外部设备通信的两种方式"><a href="#处理器与外部设备通信的两种方式" class="headerlink" title="处理器与外部设备通信的两种方式"></a>处理器与外部设备通信的两种方式</h2><p>1） 并行通信：数据各个位同时传输、速度较快、占用引脚资源多</p>
<p>2） 串行通信：数据按位顺序传输、速度较慢、占用引脚资源少</p>
<h2 id="串行通信的通信方式"><a href="#串行通信的通信方式" class="headerlink" title="串行通信的通信方式"></a>串行通信的通信方式</h2><p>1） 同步通信：带时钟同步信号传输，SPI（全双工）、I2C（半双工）</p>
<p>2） 异步通信：不带时钟同步信号，UART（全双工）、单总线（半双工）</p>
<h2 id="串行通信分为"><a href="#串行通信分为" class="headerlink" title="串行通信分为"></a>串行通信分为</h2><p>1） 单工：数据传输只支持数据在一个方向上传输</p>
<p>2） 半双工：允许数据在两个方向上传输，但在某一时刻只允许数据在一个方向上传输</p>
<p>3） 全双工：允许数据同时在两个方向上传输，要求收发设备都有独立的接收、发送能力</p>
<h2 id="Modbus通讯协议"><a href="#Modbus通讯协议" class="headerlink" title="Modbus通讯协议"></a>Modbus通讯协议</h2><p>Modbus协议使用的是主从通讯技术，即由主设备主动查询和操作从站设备。</p>
<p>其通信遵循以下的过程：</p>
<ul>
<li>主设备向从设备发送请求</li>
<li>从设备分析并处理主设备的请求，然后向主设备发送结果</li>
<li>如果出现任何差错，从设备将返回一个异常功能码</li>
</ul>
<p>Modbus协议的报文（或帧）的基本格式是：</p>
<p>功能码和数据区在不同类型的网络都是固定不变的，表头和校验码则因网络底层的实现方式不同而有所区别。表头包含了从站的地址，功能码告诉从站要执行何种功能，数据区是具体的信息。</p>
<p>Modbus有下列三种通信方式：</p>
<p>（1）以太网：对应的通信模式是</p>
<p>（2）异步串行传输（各种介质如有线RS-232-&#x2F;422&#x2F;485&#x2F;；光纤、无线等）：对应的通信模式是Modbus RTU 或 Modbus ASCII</p>
<p>（3）高速令牌传递网络：对应的通信模式是Modbus PLUS</p>
<h2 id="485通讯的原理"><a href="#485通讯的原理" class="headerlink" title="485通讯的原理"></a>485通讯的原理</h2><ol>
<li>物理层：485通讯使用两根信号线，分别为A线和B线，以及一个共享的地线（GND）。A线和B线分别用于发送和接收数据，可以进行全双工通信。在通讯过程中，A线和B线的电平可以相互翻转，用来表示不同的逻辑状态，如高电平表示逻辑”1”，低电平表示逻辑”0”。</li>
<li>差分信号：485通讯采用差分信号传输，即在A线和B线之间的电压差（差分电平）来表示数据。发送端根据要发送的数据，将A线和B线上的电平进行翻转，形成一个差分信号，接收端根据电压差的大小来判断接收到的数据是逻辑”1”还是逻辑”0”。</li>
<li>驱动能力：485通讯使用驱动能力较强的驱动器芯片，能够提供足够的电流来驱动长距离的传输线路。这使得485通讯可以在远距离的环境中进行数据传输，通常可以覆盖数千米的传输距离。</li>
<li>数据帧格式：485通讯中的数据通常以数据帧的形式进行传输。一般包括起始位（Start Bit）、数据位（Data Bits）、校验位（Parity Bit）和停止位（Stop Bit）。起始位和停止位用于标识数据帧的开始和结束，数据位用于携带实际的数据，校验位用于检测数据传输的错误。</li>
<li>通讯模式：485通讯可以进行点对点通讯或多点通讯。在点对点通讯中，一个发送器和一个接收器直接进行通讯。在多点通讯中，多个设备可以通过一个共享的总线进行通讯，通过给每个设备分配不同的地址来实现数据的选择性接收。</li>
</ol>
<h2 id="RS485和RS232的区别"><a href="#RS485和RS232的区别" class="headerlink" title="RS485和RS232的区别"></a>RS485和RS232的区别</h2><ol>
<li>通信方式：RS232：RS232是一种点对点通信方式，即一对发送器和接收器之间进行直接通信。只有一个发送器和一个接收器参与通信。RS485：RS485是一种多点通信方式，可以在一个总线上连接多个发送器和接收器，实现多个设备之间的通信。</li>
<li>信号电平：RS232：RS232使用负逻辑电平表示逻辑“1”（-3V至-15V）和正逻辑电平表示逻辑“0”（+3V至+15V）。RS485：RS485使用差分信号传输，即A线和B线之间的电压差表示数据。电平差分范围可以根据需要调整，一般为-7V至-12V表示逻辑“1”和+7V至+12V表示逻辑“0”。</li>
<li>传输距离：RS232：RS232通常适用于短距离通信，最常见的距离为15米左右。RS485：RS485具有较强的驱动能力，能够支持长距离通信，一般可达数千米，这使得它适用于工业环境中的长距离通信需求。</li>
<li>多点通信：RS232：由于是点对点通信，RS232通常无法实现多个设备之间的直接通信。如果需要多点通信，需要采用额外的协议或设备。RS485：RS485支持多点通信，可以在同一总线上连接多个设备，通过为每个设备分配不同的地址来实现数据的选择性接收。</li>
</ol>
<h2 id="串口通信协议UART"><a href="#串口通信协议UART" class="headerlink" title="串口通信协议UART"></a>串口通信协议UART</h2><p>UART（通用异步收&#x2F;发器）是我们单片机的串口通信接口，为全双工串行异步，UART通讯的数据包由发送设备通过自身的 TXD 接口传输到接收设备的 RXD 接口。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20230628/993465112_1687943445277/D2B5CA33BD970F64A6301FA75AE2EB22" alt="img"></p>
<p>在串口通讯的协议层中，规定了数据包的内容，它由起始位，主体数据，校验位以及停止位组成，通讯双方的数据包格式以及波特率要约定一致才能正常收发数据。</p>
<p>串口设置的一般步骤可以总结为如下几个步骤：</p>
<p>\1) 串口时钟使能，GPIO 时钟使能。</p>
<p>\2) 设置引脚复用器映射：调用 GPIO_PinAFConfig 函数。</p>
<p>\3) GPIO 初始化设置：要设置模式为复用功能。</p>
<p>\4) 串口参数初始化：设置波特率，字长，奇偶校验等参数。</p>
<p>\5) 开启中断并且初始化 NVIC，使能中断（如果需要开启中断才需要这个步骤）。</p>
<p>\6) 使能串口。</p>
<p>\7) 编写中断处理函数：函数名格式为 USARTxIRQHandler(x 对应串口号)。</p>
<h2 id="串口异步通信"><a href="#串口异步通信" class="headerlink" title="串口异步通信"></a>串口异步通信</h2><p>起始位、数据位、奇偶校验位、停止位、波特率设置</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20230628/993465112_1687943493927/D2B5CA33BD970F64A6301FA75AE2EB22" alt="img"></p>
<h2 id="SPI（串行外围设备接口）"><a href="#SPI（串行外围设备接口）" class="headerlink" title="SPI（串行外围设备接口）"></a>SPI（串行外围设备接口）</h2><p>SPI（全双工同步通信）</p>
<p>以主从方式工作，这种模式通常有一个主设备和一个或多 个从设备，需要至少4根线，它们是SDI (数据输入)、SDO (数据输出)、SCLK (时钟)、CS (片选)。</p>
<p>\1. SDO&#x2F;MOSI – 主设备数据输出，从设备数据输入;</p>
<p>\2. SDI&#x2F;MISO – 主设备数据输入，从设备数据输出;</p>
<p>\3. SCLK – 时钟信号，由主设备产生;</p>
<p>4.CS&#x2F;SS – 从设备使能信号，由主设备控制。当有多个从设备的时候，因为每个从设备上都有一个片选引脚接入到主设备机中，当我们的主设备和某个从设备通信时需要将从设备对应的片选引脚电平拉低或者是拉高。</p>
<p>CS片选信号，由主设备控制。当有多个从设备的时候，因为每个从设备上都有一个片选引脚接入到主设备机中，当我们的主设备和某个从设备通信时将需要将从设备对应的片选引脚电平拉低或者是拉高（本设计是拉低则为选中）</p>
<p>多从机模式：</p>
<p>第一种多CS，每个从机都需要一条单独的SS线；第二种菊花链，在设备信号（总线信号或中断信号）以串行的方式从一个设备依次传到下一个设备，不断循环直到数据到达目标设备。</p>
<p>SPI通讯的优势：</p>
<ul>
<li>全双工串行通信；</li>
<li>高速数据传输速率。</li>
<li>简单的软件配置；</li>
<li>极其灵活的数据传输，不限于8位，它可以是任意大小的字；</li>
<li>非常简单的硬件结构。从站不需要唯一地址（与I2C不同）。从机使用主机时钟，不需要精密时钟振荡器&#x2F;晶振（与UART不同）。不需要收发器（与CAN不同）。</li>
</ul>
<p>SPI的缺点：</p>
<ul>
<li>没有硬件从机应答信号（主机可能在不知情的情况下无处发送）；</li>
<li>通常仅支持一个主设备；</li>
<li>需要更多的引脚（与I2C不同）；</li>
<li>没有定义硬件级别的错误检查协议；</li>
<li>与RS-232和CAN总线相比，只能支持非常短的距离；</li>
</ul>
<h2 id="SPI是什么？有几条线？几种模式？"><a href="#SPI是什么？有几条线？几种模式？" class="headerlink" title="SPI是什么？有几条线？几种模式？"></a>SPI是什么？有几条线？几种模式？</h2><p>SPI，全称为Serial Peripheral Interface，是一种串行的通信协议，用于在单片机和外设之间进行通信。SPI协议通常用于连接低速的外设，例如存储器、传感器、显示器、通信芯片等。</p>
<p>SPI通信需要至少四条线，包括：</p>
<ol>
<li>MOSI（Master Output, Slave Input）：主设备输出，从设备输入。</li>
<li>MISO（Master Input, Slave Output）：主设备输入，从设备输出。</li>
<li>SCLK（Serial Clock）：时钟线，由主设备控制。</li>
<li>SS（Slave Select）：从设备选择线，由主设备控制，可以用来选择不同的从设备进行通信。</li>
</ol>
<p>SPI协议有四种模式，每种模式具有不同的时序和时钟极性，包括：</p>
<ol>
<li>模式0：时钟极性为0，时钟相位为0，数据在时钟的下降沿被采样。</li>
<li>模式1：时钟极性为0，时钟相位为1，数据在时钟的上升沿被采样。</li>
<li>模式2：时钟极性为1，时钟相位为0，数据在时钟的上升沿被采样。</li>
<li>模式3：时钟极性为1，时钟相位为1，数据在时钟的下降沿被采样。</li>
</ol>
<p>不同的模式适用于不同的硬件设备和通信要求，需要根据具体的需求进行选择和配置。</p>
<h2 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h2><p>1.它是总线，即它可以接入多个从设备</p>
<p>2.它只有两根线，即时钟线（SCL）,数据线（SDA）,但是它同一时间只有做发送或者接收线</p>
<p>3.每个连接到总线的设备，都要支持IIC，即有自己的设备地址，主机就是靠这个来区别不同的设备的</p>
<p>4.总线通过上拉电阻接到电源，即当空闲时，是高电平</p>
<p>5.多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。</p>
<p>6.具有三种传输模式：标准模式传输速率为 100kbit&#x2F;s ，快速模式为 400kbit&#x2F;s ，高速模式下可达 3.4Mbit&#x2F;s，但目前大多 I2C 设备尚不支持高速模式</p>
<p>空闲状态：I2C总线总线的SDA和SCL两条信号线同时处于高电平时，规定为总线的空闲状态。</p>
<p>开始信号：SCL 为高电平时，SDA 由高电平向低电平跳变，开始传送数据。</p>
<p>结束信号：SCL 为高电平时，SDA 由低电平向高电平跳变，结束传送数据。</p>
<p>应答信号：接收数据的 IC 在接收到 8bit 数据后，向发送数据的 IC 发出特定的低电平脉冲， 表示已收到数据。(主设备在SCL线上产生每个时钟脉冲，将在SDA线上传输一个数据位，当一个字节按数据位从高位到低位的顺序传输完后，紧接着从设备将拉低SDA线，回传给主设备一个应答位（ACK），此时才认为一个字节真正的被传输完成。)</p>
<p>CPU 向受控单元发出一个信号后，等待受控单元发出一个应答信号，CPU 接 收到应答信号后，根据实际情况作出是否继续传递信号的判断。若未收到应答信号，由判断为 受控单元出现故障。</p>
<h2 id="CAN通信介绍"><a href="#CAN通信介绍" class="headerlink" title="CAN通信介绍"></a>CAN通信介绍</h2><p>CAN（Controller Area Network）通信是一种串行通信协议，其主要原理如下：</p>
<ol>
<li>差分传输：CAN通信采用差分传输方式，即将数据信号和参考信号相减得到差分信号进行传输，可以有效地抵消噪声干扰，提高传输质量和可靠性。</li>
<li>帧格式：CAN通信采用基于帧的数据传输方式，每个数据帧包括了ID、数据和控制信息等多个部分。其中，ID用于区分不同的设备和数据类型，数据用于存储实际的数据信息，控制信息用于控制数据的发送和接收等操作。</li>
<li>网络拓扑：CAN通信的网络拓扑结构可以是总线型、星型或混合型，其中最常见的是总线型拓扑结构。在总线型拓扑结构中，所有的设备都连接到同一根总线上，通过差分传输的方式进行数据交换。</li>
<li>硬件控制：CAN通信的硬件控制主要包括时钟同步、数据帧的发送和接收、差分信号的转换和电平调整等。其中，时钟同步是保证通信数据同步的关键因素，CAN总线会在通信开始前进行同步校验以确保数据的正确性。</li>
<li>协议控制：CAN通信的协议控制包括数据的编码和解码、数据的传输确认和错误检测等。其中，数据的编码和解码是保证数据正确传输的关键因素，通过差分传输方式进行数据传输，CAN控制器会对数据进行检验和校验等操作以确保数据的正确性。</li>
</ol>
<h2 id="传输速度"><a href="#传输速度" class="headerlink" title="传输速度"></a>传输速度</h2><p>比特率（Bit&#x2F;s）和波特率，比特率是从单位看就可以知道是指每秒传输二进制的位数，而波特率是指每秒传输的码元；这里的码元我们给具体化，大家都知道串口，他的数据以帧格式传输的，即一个起始位+8位数据位+1位奇偶位+1位结束位，那么这里时候，这11位加在一起就是一个码元。</p>
<h1 id="cache的作用"><a href="#cache的作用" class="headerlink" title="cache的作用"></a>cache的作用</h1><p>缓存（Cache）是计算机系统中一种用于存储临时数据的高速存储器。它位于CPU和主存储器（如RAM）之间，用于加速对经常访问数据的读取和写入操作。缓存的主要作用是减少CPU与慢速存储器（如RAM）之间的速度差异，从而提高系统性能。</p>
<h1 id="有cache的CPU上使用DMA如何保证数据的一致性"><a href="#有cache的CPU上使用DMA如何保证数据的一致性" class="headerlink" title="有cache的CPU上使用DMA如何保证数据的一致性"></a>有cache的CPU上使用DMA如何保证数据的一致性</h1><p>缓存一致性是指确保CPU通过缓存访问的数据与内存中的实际数据保持一致。如果缓存中的数据与内存中的数据不一致，可能会导致错误的计算结果或系统行为。</p>
<p>在使用DMA时，可能会发生以下情况：</p>
<ol>
<li>DMA将数据写入内存，但CPU缓存中仍然保存有旧数据。</li>
<li>CPU将数据写入缓存，但DMA从内存中读取的是旧数据。</li>
</ol>
<p>为了确保数据一致性，可以采取以下策略：</p>
<ol>
<li>缓存刷新（Cache Flushing）：在DMA传输之前或之后，可以刷新缓存，以确保内存中的数据与缓存中的数据一致。例如，在DMA写操作之后，可以将缓存中受影响的数据行（Cache Line）标记为无效，从而在下次访问时强制从内存重新加载数据；在DMA读操作之前，可以将修改过的缓存数据写回内存，以确保DMA读取到的是最新数据。</li>
<li>缓存一致性协议（Cache Coherency Protocol）：某些处理器支持硬件缓存一致性协议，如MESI协议（Modified, Exclusive, Shared, and Invalid），用于自动维护多个缓存之间的数据一致性。这种协议可以在多核处理器或多处理器系统中使用，以便在DMA传输时自动更新相关缓存数据。</li>
<li>无缓存访问（Uncached Access）：在某些情况下，可以将DMA操作的内存区域配置为无缓存访问，即CPU直接访问内存，而不经过缓存。这样可以避免缓存一致性问题，但可能会降低数据访问性能。</li>
<li>使用缓冲区同步技术：某些操作系统或驱动程序可以提供缓冲区同步技术，如Linux内核中的函数，用于确保DMA操作和CPU访问之间的缓存一致性。</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-LeetCodeTop100"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/26/LeetCodeTop100/"
    >LeetCodeTop100</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/26/LeetCodeTop100/" class="article-date">
  <time datetime="2023-07-25T16:00:00.000Z" itemprop="datePublished">2023-07-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%98%9F%E6%B5%B7/">星海</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="力扣TOP100"><a href="#力扣TOP100" class="headerlink" title="力扣TOP100"></a>力扣TOP100</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.2">哈希</a><a name="context.2"> </a></li>
<li><a href="#section.3">双指针</a><a name="context.3"> </a></li>
<li><a href="#section.4">滑动窗口</a><a name="context.4"> </a></li>
<li><a href="#section.5">子串</a><a name="context.5"> </a></li>
<li><a href="#section.6">数组</a><a name="context.6"> </a></li>
<li><a href="#section.7">矩阵</a><a name="context.7"> </a></li>
<li><a href="#section.8">链表</a><a name="context.8"> </a></li>
</ul>
<hr> 
      <a class="article-more-link" href="/2023/07/26/LeetCodeTop100/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%98%9F%E6%B5%B7/" rel="tag">星海</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023
        <i class="ri-heart-fill heart_icon"></i> Nrui
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/favicon.ico" alt="MustWin"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>